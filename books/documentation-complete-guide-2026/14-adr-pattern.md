---
title: "ADR（Architecture Decision Records）"
---

# ADR（Architecture Decision Records）

## この章で学ぶこと

ソフトウェア開発において、私たちは日々多くの設計判断を行います。「なぜPostgreSQLを選んだのか」「なぜモノリスではなくマイクロサービスにしたのか」「なぜREST APIではなくGraphQLを採用したのか」。これらの判断は、その時点では明確な理由があっても、時間が経つと忘れられ、後から「なぜこうなっているのか」が分からなくなります。

ADR（Architecture Decision Records）は、このような設計判断を記録するための軽量で実践的なフレームワークです。この章では、ADRの基礎から実践的な使い方、チームでの運用方法まで、包括的に学びます：

- ADRとは何か、なぜ必要なのか
- ADRの基本構造とテンプレート
- 実践的なADRの例（データベース選定、アーキテクチャパターン、技術選定など）
- ADRの管理方法とワークフロー
- チームでのADR運用のベストプラクティス
- ADRツールの活用

ADRは、未来の自分やチームメンバーへの贈り物です。適切に記録された設計判断は、プロジェクトの保守性を高め、不要な変更を防ぎ、チームの意思決定プロセスを透明化します。

## ADRとは何か

### ADRの定義

ADR（Architecture Decision Records）は、ソフトウェアアーキテクチャにおける重要な設計判断を記録するための短い文書です。Michael Nygardによって2011年に提唱され、現在では多くの組織で採用されています。

**ADRの特徴**：

1. **軽量**: 1つのADRは通常1〜2ページ程度
2. **イミュータブル**: 一度書いたADRは変更せず、新しいADRで上書きする
3. **バージョン管理**: コードと同じリポジトリで管理
4. **検索可能**: プレーンテキストなので検索しやすい
5. **時系列**: 連番で管理し、意思決定の歴史を追える

### なぜADRが必要なのか

#### 1. 記憶は曖昧

プロジェクトが数ヶ月、数年と進むにつれて、なぜその設計を選んだのか忘れてしまいます。

**よくある状況**：

```
エンジニアA: 「なんでこのプロジェクト、PostgreSQLじゃなくてMySQLなの？」
エンジニアB: 「えーと、確か前任者が...理由は分からないけど」
エンジニアC: 「当時の議事録探してみるか...」（見つからない）
```

**ADRがあれば**：

```
エンジニアA: 「なんでMySQL？」
エンジニアB: 「ADR-003に書いてあるよ」
→ すぐに理由が分かる
```

#### 2. 同じ議論の繰り返しを防ぐ

記録がないと、同じ技術選定の議論が何度も繰り返されます。

**ADRがない場合**：

```
2023年: GraphQLにするかRESTにするか、2週間議論してRESTに決定
2024年: 新メンバー「GraphQLにしませんか？」
       → また同じ議論を2週間
2025年: 別の新メンバー「GraphQLにしませんか？」
       → また同じ議論...
```

**ADRがある場合**：

```
新メンバー: 「GraphQLにしませんか？」
既存メンバー: 「ADR-007を見て。当時の検討内容と判断理由が書いてある」
新メンバー: 「なるほど、その理由なら納得です。でも状況が変わったので再検討する価値はあるかも」
→ 建設的な議論が可能
```

#### 3. 意思決定プロセスの透明化

誰が、いつ、なぜ、どのような判断をしたのかが記録されます。

**透明性がもたらすもの**：

- **信頼の構築**: チームメンバーが意思決定プロセスを理解できる
- **説明責任**: 判断の根拠が明確になる
- **学習機会**: 過去の判断から学べる

#### 4. オンボーディングの効率化

新しいメンバーがプロジェクトのアーキテクチャを理解する際、ADRは貴重なリソースになります。

**新メンバーの理解促進**：

```markdown
# オンボーディング資料

## 1. READMEを読む（プロジェクト概要）
## 2. アーキテクチャ図を見る（全体構造）
## 3. ADRを時系列で読む（設計判断の歴史）
   - ADR-001: モノリスからマイクロサービスへの移行
   - ADR-002: データベース選定
   - ADR-003: 認証方式の決定
   ...
```

### ADRと他のドキュメントとの違い

#### ADR vs 設計書

| 観点 | ADR | 従来の設計書 |
|------|-----|-------------|
| 目的 | 判断の記録 | システムの説明 |
| 更新頻度 | イミュータブル（変更しない） | 継続的に更新 |
| 粒度 | 1つの判断に1つのADR | 包括的な設計 |
| メンテナンス | 不要（追記のみ） | 継続的なメンテナンスが必要 |
| 長さ | 1〜2ページ | 数十ページ以上 |

#### ADR vs コメント

| 観点 | ADR | コードコメント |
|------|-----|---------------|
| 対象 | アーキテクチャレベルの判断 | 実装レベルの説明 |
| スコープ | システム全体やコンポーネント単位 | 関数や数行のコード |
| 検索性 | 集約された場所に配置 | コード内に分散 |
| 読者 | アーキテクト、テックリード、全エンジニア | そのコードを触るエンジニア |

**使い分けの例**：

```typescript
// ❌ コメントに書くべきではない（ADRに書くべき）
// 【重要】このプロジェクトでは、データベースにPostgreSQLを使用しています。
// MySQLも検討しましたが、JSON型のサポートとGIS機能の必要性から
// PostgreSQLを選択しました。詳細な比較検討は2024年1月の
// ミーティング資料を参照してください。
const db = new PostgreSQLClient();

// ✅ コメントに書くべき内容（実装の理由）
// タイムゾーン変換は明示的に行う（暗黙的な変換はバグの原因）
// 詳細: docs/adr/ADR-015-timezone-handling.md
const utcDate = convertToUTC(localDate);
```

#### ADR vs 議事録

| 観点 | ADR | 会議議事録 |
|------|-----|----------|
| 構造 | 定型テンプレート | 自由形式 |
| 結論 | 必ず明記 | 必ずしも明確でない |
| 永続性 | 永続的に保管 | 一時的な記録 |
| 検索性 | タイトルとタグで検索 | 全文検索が必要 |

**ADRと議事録の関係**：

```
会議で議論 → 議事録に記録 → 決定事項をADRとして正式に記録
```

## ADRの基本構造

### Michael Nygardのテンプレート

ADRの元祖となるテンプレートです。シンプルで実践的な構造を持っています。

```markdown
# ADR-001: [タイトル]

## Status

[Proposed | Accepted | Deprecated | Superseded]

## Context

何が問題で、どのような状況でこの判断が必要になったのか。

## Decision

どのような判断をしたのか。

## Consequences

この判断によって何が良くなり、何がトレードオフになるのか。
```

#### 各セクションの詳細

**1. タイトル**

- 明確で検索しやすい
- 判断内容が一目で分かる
- 動詞形で書く（「〜を採用」「〜に移行」）

**良いタイトルの例**：

```
✅ ADR-001: データベースにPostgreSQLを採用
✅ ADR-002: モノリスからマイクロサービスへ移行
✅ ADR-003: 認証にAuth0を使用
✅ ADR-004: GraphQLではなくREST APIを継続使用
```

**悪いタイトルの例**：

```
❌ ADR-001: データベース（何を決めたか不明）
❌ ADR-002: システム設計について（範囲が広すぎる）
❌ ADR-003: メモ（タイトルになっていない）
```

**2. Status（ステータス）**

判断の現在の状態を示します。

| ステータス | 意味 | 使用タイミング |
|-----------|------|--------------|
| **Proposed** | 提案中 | レビュー中、まだ承認されていない |
| **Accepted** | 承認済み | チームで合意し、実装中または実装済み |
| **Deprecated** | 非推奨 | 新しいADRで置き換えられた |
| **Superseded** | 廃止 | 完全に別のADRに置き換えられた |

**ステータスの遷移例**：

```
Proposed → Accepted → Deprecated → Superseded
          ↓
       Rejected（却下の場合）
```

**ステータスの記載例**：

```markdown
## Status

Accepted (2024-01-15)

## Status

Superseded by ADR-025 (2024-06-20)
```

**3. Context（背景）**

なぜこの判断が必要になったのか、どのような状況だったのかを説明します。

**含まれるべき内容**：

- 解決すべき問題
- 技術的な制約
- ビジネス要件
- 検討した選択肢
- 当時の状況（チームの規模、予算、スケジュールなど）

**良いContextの例**：

```markdown
## Context

現在、ユーザー認証は自社実装のJWTベースのシステムを使用している。
しかし、以下の問題が発生している：

1. セキュリティ: 定期的な脆弱性対応が必要だが、専門性が不足
2. 機能: OAuth2.0、SAML、多要素認証への対応が困難
3. 保守: 認証コードのメンテナンスに月20時間以上を費やしている

検討した選択肢：
- A案: 自社実装を継続し、セキュリティエンジニアを採用
- B案: Auth0を導入（月額$200〜）
- C案: AWS Cognitoを導入（従量課金）
- D案: Keycloakをセルフホスト

制約条件：
- 予算: 認証に月額$500まで
- スケジュール: 3ヶ月以内に移行完了
- チーム: フロントエンド2名、バックエンド2名
```

**悪いContextの例**：

```markdown
## Context

認証システムが必要だから。

（何が問題で、どんな選択肢があったのか不明）
```

**4. Decision（決定）**

何を決めたのかを明確に記載します。

**良いDecisionの例**：

```markdown
## Decision

Auth0を認証基盤として採用する。

具体的には：
- ユーザー認証: Auth0 Universal Login
- API認証: Auth0 JWT (Access Token)
- ソーシャルログイン: Auth0のソーシャル接続機能
- 多要素認証: Auth0 MFA（段階的に導入）

移行計画：
- Phase 1 (Month 1): 新規ユーザーはAuth0で登録
- Phase 2 (Month 2): 既存ユーザーの段階的移行
- Phase 3 (Month 3): 旧システムの廃止
```

**悪いDecisionの例**：

```markdown
## Decision

Auth0を使うことにした。

（具体性に欠け、どう使うのか不明）
```

**5. Consequences（結果・影響）**

この判断によって何が良くなり、何がトレードオフになるのかを記載します。

**含まれるべき内容**：

- **Positive（利点）**: 何が改善されるか
- **Negative（欠点）**: 何を犠牲にするか
- **Risks（リスク）**: 潜在的な問題
- **Trade-offs（トレードオフ）**: 選ばなかった選択肢との比較

**良いConsequencesの例**：

```markdown
## Consequences

### Positive（利点）

1. **セキュリティの向上**
   - OWASP Top 10への対応が自動化
   - 専門チームによる継続的なセキュリティアップデート

2. **開発生産性の向上**
   - 認証機能の開発・保守に費やす時間がゼロに
   - 多要素認証、ソーシャルログインが即座に利用可能

3. **将来の拡張性**
   - エンタープライズ機能（SAML、SSO）への対応が容易

### Negative（欠点）

1. **コスト増加**
   - 月額$0 → $200〜500（ユーザー数に応じて）
   - 初期移行コスト: 約200時間

2. **ベンダーロックイン**
   - Auth0固有のAPIに依存
   - 将来的な移行コストが発生する可能性

3. **カスタマイズの制約**
   - 自社実装より柔軟性が低い
   - Auth0の仕様変更に影響を受ける

### Risks（リスク）

1. **Auth0のサービス停止**
   - 軽減策: SLA 99.99%の契約、障害時の代替フロー設計

2. **予想以上のユーザー増加によるコスト増**
   - 軽減策: 月次でコストモニタリング、予算超過アラート設定

### Trade-offs（トレードオフ）

- AWS Cognitoと比較すると、Auth0はコストが高いが、UXと機能性で優位
- セルフホストのKeycloakと比較すると、Auth0は柔軟性で劣るが、運用負荷が圧倒的に低い
```

### その他のテンプレート

#### Y-Statements（簡易版）

より簡潔な記述を好む場合に使用します。

```markdown
# ADR-001: データベースにPostgreSQLを採用

In the context of [USE CASE / USER STORY],
facing [CONCERN],
we decided for [OPTION],
to achieve [QUALITY],
accepting [DOWNSIDE].

（日本語版）

[ユースケース・ユーザーストーリー]において、
[懸念事項]に直面し、
[選択肢]を選択することで、
[達成したい品質]を実現する。
ただし、[受け入れるべき欠点]を受け入れる。
```

**具体例**：

```markdown
# ADR-001: データベースにPostgreSQLを採用

位置情報機能を持つモバイルアプリのバックエンド開発において、
地理空間データの効率的な処理という懸念に直面し、
PostgreSQL + PostGISを選択することで、
高速な位置検索と豊富な地理空間関数を実現する。
ただし、チームのMySQL経験が活かせないという欠点を受け入れる。
```

#### MADR（Markdown Any Decision Records）

より詳細な記録を好む場合のテンプレートです。

```markdown
# [タイトル]

* Status: [Proposed | Accepted | Rejected | Deprecated | Superseded]
* Deciders: [意思決定者のリスト]
* Date: [YYYY-MM-DD]
* Technical Story: [チケット番号やIssueへのリンク]

## Context and Problem Statement

[問題の記述]

## Decision Drivers

* [意思決定に影響を与える要因1]
* [意思決定に影響を与える要因2]
* ...

## Considered Options

* [選択肢1]
* [選択肢2]
* [選択肢3]
* ...

## Decision Outcome

Chosen option: "[選択した選択肢]", because [理由].

### Positive Consequences

* [利点1]
* [利点2]
* ...

### Negative Consequences

* [欠点1]
* [欠点2]
* ...

## Pros and Cons of the Options

### [選択肢1]

* Good, because [理由]
* Bad, because [理由]
* ...

### [選択肢2]

* Good, because [理由]
* Bad, because [理由]
* ...

## Links

* [関連ドキュメントへのリンク]
* [参考資料]
```

## 実践的なADRの例

### 例1: データベース選定

```markdown
# ADR-003: データベースにPostgreSQLを採用

## Status

Accepted (2024-01-20)

## Context

新しいSaaSプロダクトのバックエンド開発を開始するにあたり、
データベース選定を行う必要がある。

### 要件

**機能要件**:
- ユーザー情報、組織情報、課金情報の永続化
- 複雑なクエリ（JOIN、集計、全文検索）のサポート
- JSON形式の柔軟なメタデータ保存
- トランザクションの完全なACID保証

**非機能要件**:
- 初期: 10,000ユーザー、100万レコード
- 1年後: 100,000ユーザー、1,000万レコード
- 可用性: 99.9%以上
- RPO/RTO: 1時間/4時間

### 検討した選択肢

1. **PostgreSQL**
   - オープンソースのリレーショナルデータベース
   - JSON型、全文検索、GIS機能が充実

2. **MySQL**
   - 世界で最も普及しているオープンソースDB
   - シンプルで学習コストが低い

3. **MongoDB**
   - ドキュメント指向データベース
   - スキーマレスで柔軟性が高い

### 制約条件

- **予算**: データベースに月額$500まで（マネージドサービスの場合）
- **チーム**: バックエンドエンジニア3名（全員がSQL経験あり、NoSQL未経験）
- **スケジュール**: 3ヶ月でMVPリリース

## Decision

**PostgreSQLを採用する**。

具体的には：
- **ホスティング**: AWS RDS for PostgreSQL
- **バージョン**: PostgreSQL 15（最新安定版）
- **構成**: Multi-AZ（高可用性）
- **インスタンス**: db.t3.medium（開発初期、必要に応じてスケール）

### 採用理由

1. **JSON型のサポート**
   - ユーザーのメタデータなど、スキーマが流動的なデータに対応
   - JSONB型により、インデックス作成とクエリが高速

2. **全文検索機能**
   - 組み込みの全文検索機能（ts_vector、ts_query）
   - 別途ElasticsearchやAlgoliaを導入する必要がない（コスト削減）

3. **チームの経験**
   - 全メンバーがSQLを習得済み
   - MongoDBは学習コストが高い

4. **トランザクション**
   - 課金処理など、厳密なACIDトランザクションが必要
   - PostgreSQLは完全なACID保証

5. **エコシステム**
   - ORMサポート（Prisma、TypeORM、Sequelize）が充実
   - 豊富なツールとコミュニティ

## Consequences

### Positive（利点）

1. **開発速度の向上**
   - チームの既存知識を活用できる
   - 学習コストが最小限
   - ORMとの統合が容易

2. **機能の豊富さ**
   - JSON型により、NoSQLのような柔軟性
   - 全文検索、GIS機能など、追加サービス不要

3. **コスト効率**
   - RDSのt3.mediumで月額$100程度（予算内）
   - Elasticsearchなどのミドルウェアが不要

4. **運用の容易さ**
   - AWS RDSによる自動バックアップ
   - 自動パッチ適用
   - モニタリングツール（CloudWatch）との統合

### Negative（欠点）

1. **水平スケーリングの制約**
   - 垂直スケーリング（スペック向上）が基本
   - 水平スケーリング（シャーディング）は複雑
   - ただし、初期の1〜2年は問題にならない見込み

2. **NoSQLより柔軟性が低い**
   - スキーマ変更にマイグレーションが必要
   - ただし、JSON型である程度カバー可能

3. **書き込みスループット**
   - MongoDBと比較すると、大量の書き込みには弱い
   - ただし、要件上は問題ない（OLTP中心）

### Risks（リスク）

1. **急激なユーザー増加**
   - リスク: 想定以上のユーザー増加でスケールが追いつかない
   - 軽減策: 早期のパフォーマンステスト、Read Replicaの活用

2. **RDSのコスト増加**
   - リスク: データ量増加により、予想以上にコストが上昇
   - 軽減策: 月次でコストモニタリング、古いデータのアーカイブ戦略

3. **ベンダーロックイン（AWS）**
   - リスク: AWSから他のクラウドへの移行が困難
   - 軽減策: アプリケーション層でDBアクセスを抽象化

### 将来的な見直しポイント

以下の状況になった場合、この判断を再検討する：

1. **ユーザー数が100万を超えた場合**
   - シャーディングやNewSQLの検討

2. **リアルタイム分析が必要になった場合**
   - OLAP用のデータウェアハウス（Redshift、BigQuery）の追加

3. **グローバル展開が必要になった場合**
   - マルチリージョン対応（Aurora Globalなど）の検討

## References

- [PostgreSQL Official Documentation](https://www.postgresql.org/docs/)
- [AWS RDS for PostgreSQL](https://aws.amazon.com/rds/postgresql/)
- [Prisma PostgreSQL Guide](https://www.prisma.io/docs/concepts/database-connectors/postgresql)

## Related ADRs

- ADR-004: ORMにPrismaを採用
- ADR-012: キャッシュ戦略（Redis使用）
```

### 例2: モノリスからマイクロサービスへの移行

```markdown
# ADR-015: モノリスからマイクロサービスへの段階的移行

## Status

Accepted (2024-03-15)

## Context

現在、弊社のECプラットフォームは単一のRuby on Railsアプリケーション
（以下、「モノリス」）として実装されている。

### 現在の問題

1. **デプロイの困難さ**
   - 全機能が1つのアプリケーション
   - 小さな変更でも全体をデプロイ
   - デプロイ時間: 約30分、週1回が限界

2. **スケーラビリティの問題**
   - 画像処理が重く、全体のパフォーマンスに影響
   - 特定の機能だけスケールできない

3. **チーム間の依存**
   - 5チーム（商品、注文、決済、配送、カスタマーサポート）
   - 同じコードベースで作業、頻繁にコンフリクト
   - リリース調整に多大な時間

4. **技術的負債**
   - Rails 5（EOL間近）
   - バージョンアップが大規模すぎて困難
   - 新技術の導入が事実上不可能

### 検討した選択肢

1. **A案: モノリスのまま最適化**
   - 利点: リスクが低い、既存の知識が活用できる
   - 欠点: 根本的な問題は解決しない

2. **B案: 完全なマイクロサービス化（一気に移行）**
   - 利点: 最終的な理想形に早く到達
   - 欠点: リスクが高すぎる、ビジネスが止まる可能性

3. **C案: Strangler Fig パターンで段階的に移行**
   - 利点: リスクを抑えながら段階的に進められる
   - 欠点: 移行期間が長い、一時的に複雑性が増す

### 制約条件

- **ビジネス**: 移行中もサービスを継続（ダウンタイムは最小限）
- **チーム**: 各チーム5名、計25名
- **予算**: 新規インフラに月額$5,000まで
- **期間**: 18ヶ月で主要機能の移行完了

## Decision

**Strangler Figパターンで段階的にマイクロサービスへ移行する**。

### 移行戦略

**Phase 1: 独立性の高い機能から移行（Month 1-6）**

1. **画像処理サービス**（Month 1-2）
   - 最も独立性が高い
   - パフォーマンス問題の主因
   - 技術スタック: Node.js + Sharp

2. **通知サービス**（Month 3-4）
   - メール、SMS、プッシュ通知
   - 技術スタック: Go + AWS SQS

3. **検索サービス**（Month 5-6）
   - 商品検索、フィルタリング
   - 技術スタック: Elasticsearch + Nest.js

**Phase 2: ビジネスドメインごとに分離（Month 7-12）**

4. **決済サービス**（Month 7-9）
   - Stripe、PayPal連携
   - 技術スタック: Node.js + TypeScript

5. **在庫管理サービス**（Month 10-12）
   - 在庫数、予約、配送準備
   - 技術スタック: Go

**Phase 3: コア機能の移行（Month 13-18）**

6. **注文サービス**（Month 13-15）
7. **商品カタログサービス**（Month 16-18）

**Phase 4以降: 残りの機能を順次移行**

### アーキテクチャ

```
                    ┌─────────────┐
                    │  API Gateway │
                    │   (Kong)     │
                    └──────┬───────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
   ┌────▼────┐      ┌─────▼─────┐     ┌─────▼──────┐
   │ 新規    │      │ 新規      │     │ モノリス    │
   │ Service │      │ Service   │     │ (Rails)     │
   │ (Node)  │      │ (Go)      │     │ (既存)      │
   └─────────┘      └───────────┘     └────────────┘
```

### 技術選定

- **API Gateway**: Kong（ルーティング、認証、レート制限）
- **サービス間通信**: REST API + イベントバス（AWS EventBridge）
- **データベース**: サービスごとに独立したDB
- **認証**: 共通のAuth Service（Auth0）
- **モニタリング**: Datadog
- **ログ**: CloudWatch Logs
- **トレーシング**: AWS X-Ray

## Consequences

### Positive（利点）

1. **デプロイの独立性**
   - 各サービスが独立してデプロイ可能
   - デプロイ頻度: 週1回 → 1日複数回
   - デプロイ時間: 30分 → 5分

2. **スケーラビリティの向上**
   - 負荷の高いサービス（画像処理）だけスケール
   - コスト最適化

3. **チームの自律性**
   - 各チームが独立して開発・デプロイ
   - 技術スタックの選択が可能
   - コンフリクトの減少

4. **障害の局所化**
   - 1つのサービスの障害が全体に波及しない
   - 復旧が容易

5. **段階的な移行**
   - ビジネスを止めずに移行
   - 各フェーズで学習し、改善

### Negative（欠点）

1. **システムの複雑性増加**
   - サービス数の増加
   - ネットワークコールの増加
   - デバッグの困難さ

2. **運用コストの増加**
   - インフラコスト: +$3,000/月
   - モニタリングツール: +$1,000/月
   - 学習コスト: チーム全体で約500時間

3. **データ整合性の課題**
   - 分散トランザクションの管理が必要
   - Sagaパターンなどの実装が必要

4. **移行期間の複雑さ**
   - モノリスと新サービスが併存
   - データ同期の必要性
   - 一時的な技術的負債

### Risks（リスク）

1. **移行の長期化**
   - リスク: 18ヶ月で終わらない可能性
   - 軽減策: 3ヶ月ごとにマイルストーンを設定、進捗を厳密に管理

2. **パフォーマンス劣化**
   - リスク: ネットワークオーバーヘッドによる遅延
   - 軽減策: キャッシュ戦略、非同期処理の活用

3. **データ不整合**
   - リスク: サービス間のデータが不整合になる
   - 軽減策: イベント駆動アーキテクチャ、Sagaパターン

4. **チームのスキル不足**
   - リスク: 分散システムの経験が不足
   - 軽減策: 外部コンサルタントの活用、トレーニング

### 成功の指標（KPI）

移行の成功を測定するための指標：

1. **デプロイ頻度**: 週1回 → 1日3回以上
2. **デプロイ時間**: 30分 → 5分以内
3. **MTTR（平均復旧時間）**: 2時間 → 30分以内
4. **障害の影響範囲**: 全体 → 特定サービスのみ
5. **チーム間のコンフリクト**: 月10回 → 月2回以下

### 見直しポイント

以下の状況になった場合、戦略を見直す：

1. **Phase 1で重大な問題が発覚**
   - 移行ペースを落とす、またはアプローチを変更

2. **コストが予算の150%を超える**
   - スコープの縮小、または一部モノリスに戻す

3. **パフォーマンスが20%以上悪化**
   - アーキテクチャの再検討

## References

- [Strangler Fig Pattern](https://martinfowler.com/bliki/StranglerFigApplication.html)
- [Microservices Patterns by Chris Richardson](https://microservices.io/patterns/)
- [Building Microservices by Sam Newman](https://www.oreilly.com/library/view/building-microservices-2nd/9781492034018/)

## Related ADRs

- ADR-016: API Gatewayの選定
- ADR-017: サービス間通信の戦略
- ADR-018: データ整合性の保証方法
- ADR-019: モニタリング戦略
```

### 例3: フロントエンドフレームワーク選定

```markdown
# ADR-008: フロントエンドフレームワークにNext.jsを採用

## Status

Accepted (2024-02-10)

## Context

新しいWebアプリケーションのフロントエンド開発を開始するにあたり、
フレームワークを選定する必要がある。

### 要件

**機能要件**:
- マーケティングページ（LP、ブログ、ドキュメント）
- 認証が必要なダッシュボード（SPA）
- SEO対応（検索エンジンでの上位表示が重要）
- SNSシェア時のOGP画像生成

**非機能要件**:
- 初期表示速度: 3秒以内（LCPが2.5秒以内）
- Core Web Vitals: すべてGood
- アクセシビリティ: WCAG 2.1 AA準拠

### 検討した選択肢

1. **Next.js（React）**
   - フルスタックReactフレームワーク
   - SSR、SSG、ISRをサポート
   - Vercelによる公式サポート

2. **Remix（React）**
   - 新しいフルスタックReactフレームワーク
   - ネストされたルーティングが特徴
   - Web標準重視

3. **SvelteKit（Svelte）**
   - Svelteのフルスタックフレームワーク
   - 軽量、高速
   - コンパイル時の最適化

4. **Vue.js + Nuxt.js**
   - Vueのフルスタックフレームワーク
   - 学習コストが低い
   - 日本語の情報が豊富

### 制約条件

- **チーム**: フロントエンドエンジニア3名（React経験あり）
- **スケジュール**: 4ヶ月でMVPリリース
- **予算**: インフラに月額$300まで

## Decision

**Next.js 14（App Router）を採用する**。

具体的には：
- **バージョン**: Next.js 14.x（最新版）
- **ルーティング**: App Router（新アーキテクチャ）
- **レンダリング戦略**:
  - マーケティングページ: SSG（静的生成）
  - ブログ: ISR（増分静的再生成、revalidate: 3600秒）
  - ダッシュボード: CSR（クライアントサイド）
- **ホスティング**: Vercel（Hobby Plan → Pro Plan）
- **言語**: TypeScript
- **スタイリング**: Tailwind CSS

### 採用理由

1. **チームの経験**
   - 全員がReact経験あり
   - Next.jsは2名が業務経験あり
   - 学習コストが最小限

2. **レンダリング戦略の柔軟性**
   - SSG: マーケティングページ（高速、SEO◎）
   - ISR: ブログ（更新頻度とパフォーマンスのバランス）
   - CSR: ダッシュボード（インタラクティブ、SEO不要）
   - ページごとに最適な戦略を選択可能

3. **SEO対応**
   - サーバーサイドレンダリングでクローラーに完全なHTMLを提供
   - メタタグの動的生成
   - 構造化データの簡単な実装

4. **エコシステム**
   - 豊富なライブラリとコミュニティ
   - Vercelの公式サポート
   - Next.js専用のベストプラクティスが確立

5. **パフォーマンス**
   - 自動的な画像最適化（next/image）
   - コード分割（自動）
   - フォントの最適化（next/font）

6. **開発者体験**
   - Fast Refresh（変更が即座に反映）
   - TypeScriptの完全サポート
   - 優れたエラーメッセージ

## Consequences

### Positive（利点）

1. **開発速度の向上**
   - チームの既存知識を活用
   - 豊富なドキュメントとチュートリアル
   - BoilerplateやテンプレートがXlenty

2. **SEO対応の容易さ**
   - SSG/SSRによる完全なHTML生成
   - メタデータAPIで動的なSEO設定
   - サイトマップの自動生成

3. **パフォーマンス**
   - Core Web Vitalsで高スコアが期待できる
   - 画像最適化が自動的
   - ゼロコンフィグで最適化

4. **ホスティングの容易さ**
   - Vercelへのデプロイが1コマンド
   - プレビューデプロイ（PR単位）
   - エッジ関数のサポート

### Negative（欠点）

1. **ベンダーロックイン（Vercel）**
   - Next.jsはVercel製、他のホストでは最適化が限定的
   - ただし、他のホスト（AWS、GCP）でも動作可能

2. **バンドルサイズ**
   - Reactベースなので、Svelteと比較すると大きい
   - 初期JS: 約85KB（gzip）
   - ただし、要件上は許容範囲

3. **学習コスト（App Router）**
   - App Routerは新しく、情報が少ない
   - Server ComponentsとClient Componentsの使い分けが必要
   - ただし、公式ドキュメントは充実

4. **サーバーが必要（一部機能）**
   - ISRやAPIルートにはサーバー（Vercel、またはNode.js環境）が必要
   - 完全な静的サイトホスティング（S3など）では制約

### Risks（リスク）

1. **Next.js 14の安定性**
   - リスク: App Routerは比較的新しく、バグの可能性
   - 軽減策: 初期はPages Routerも検討可能、段階的にApp Routerへ

2. **Vercelのコスト増加**
   - リスク: トラフィック増加によるコスト増
   - 軽減策: 月次モニタリング、必要に応じて他ホストへ移行

3. **チームのキャッチアップ**
   - リスク: App Routerの新概念に慣れるまで時間がかかる
   - 軽減策: キックオフ時に2日間のハンズオントレーニング

### 代替案との比較

| 観点 | Next.js | Remix | SvelteKit | Nuxt.js |
|------|---------|-------|-----------|---------|
| チーム経験 | ◎ | △ | △ | ○ |
| SEO | ◎ | ◎ | ◎ | ◎ |
| パフォーマンス | ◎ | ◎ | ◎◎ | ◎ |
| エコシステム | ◎◎ | ○ | ○ | ◎ |
| ホスティング | ◎（Vercel） | ○ | ○ | ◎（Vercel） |
| 学習コスト | ○ | △ | △ | ◎ |

## References

- [Next.js Documentation](https://nextjs.org/docs)
- [Next.js App Router](https://nextjs.org/docs/app)
- [Vercel Deployment](https://vercel.com/docs)
- [React Server Components](https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-server-components)

## Related ADRs

- ADR-009: 状態管理にZustandを採用
- ADR-010: スタイリングにTailwind CSSを採用
- ADR-011: ホスティングにVercelを使用
```

## ADRの管理方法

### ディレクトリ構造

**推奨される配置**：

```
project/
├── docs/
│   └── adr/
│       ├── README.md（ADRのインデックス）
│       ├── template.md（テンプレート）
│       ├── 0001-use-postgresql.md
│       ├── 0002-adopt-microservices.md
│       ├── 0003-use-nextjs.md
│       └── ...
├── src/
└── README.md
```

**README.mdの例**：

```markdown
# Architecture Decision Records (ADR)

このディレクトリには、プロジェクトの重要な設計判断を記録したADRが含まれています。

## ADR一覧

| # | タイトル | ステータス | 日付 |
|---|---------|-----------|------|
| [001](0001-use-postgresql.md) | データベースにPostgreSQLを採用 | Accepted | 2024-01-20 |
| [002](0002-adopt-microservices.md) | マイクロサービスへの移行 | Accepted | 2024-03-15 |
| [003](0003-use-nextjs.md) | Next.jsを採用 | Accepted | 2024-02-10 |

## カテゴリ別

### データベース
- ADR-001: PostgreSQLの採用
- ADR-004: ORMにPrismaを採用
- ADR-012: キャッシュ戦略

### アーキテクチャ
- ADR-002: マイクロサービスへの移行
- ADR-016: API Gatewayの選定

### フロントエンド
- ADR-003: Next.jsの採用
- ADR-009: Zustandの採用
- ADR-010: Tailwind CSSの採用

## ADRの作成方法

1. `template.md`をコピー
2. 連番を付けてファイル名を決定（例：`0004-my-decision.md`）
3. テンプレートに従って記入
4. PRを作成し、チームレビュー
5. マージ後、このREADMEを更新
```

### 命名規則

**ファイル名**：

```
[連番]-[判断内容].md

例:
0001-use-postgresql.md
0002-adopt-microservices.md
0023-migrate-to-kubernetes.md
```

**連番の付け方**：

- **0001〜0999**: 通常のADR
- **ゼロパディング**: 4桁（例：0001、0023、0100）
- **連番の欠番**: 欠番があってもOK（削除したADRがあっても良い）

### ステータス管理

**ステータスの更新方法**：

```markdown
## Status

Superseded by ADR-025 (2024-06-20)

Previous status: Accepted (2024-01-20)
```

**ステータス遷移の例**：

```
# ADR-001: 旧判断
## Status
Superseded by ADR-010 (2024-06-01)

# ADR-010: 新判断
## Status
Accepted (2024-06-01)

This ADR supersedes ADR-001.
```

### バージョン管理

**Gitでの管理**：

```bash
# ADRの作成
git add docs/adr/0005-new-decision.md
git commit -m "docs: Add ADR-005 for authentication strategy"

# ADRの更新（ステータス変更のみ）
git add docs/adr/0003-old-decision.md
git commit -m "docs: Deprecate ADR-003, superseded by ADR-012"
```

**コミットメッセージの規約**：

```
docs: Add ADR-XXX for [判断内容]
docs: Update ADR-XXX status to [新ステータス]
docs: Supersede ADR-XXX with ADR-YYY
```

## ADRのワークフロー

### 作成プロセス

```
1. 判断が必要な状況の認識
   ↓
2. ADRドラフトの作成（Status: Proposed）
   ↓
3. チーム内レビュー・議論
   ↓
4. 必要に応じて修正
   ↓
5. 合意形成
   ↓
6. ステータスをAcceptedに変更
   ↓
7. マージ
   ↓
8. 実装
```

### レビューのポイント

**レビュアーが確認すべきこと**：

1. **明確性**
   - 判断内容が明確か
   - タイトルが適切か
   - 専門用語が説明されているか

2. **完全性**
   - Contextが十分に説明されているか
   - 検討した選択肢がすべて列挙されているか
   - Consequencesが正直に書かれているか

3. **正確性**
   - 技術的な記述が正確か
   - 情報源が明記されているか
   - 実測していないデータを「実測」としていないか

4. **有用性**
   - 将来の意思決定に役立つか
   - トレードオフが明確か
   - 見直しポイントが明記されているか

**レビューコメントの例**：

```markdown
## 良いレビューコメント

✅ "Contextに、なぜ今この判断が必要なのかを追記してください"
✅ "Consequencesに、MongoDBを選ばなかった理由も書いた方が良いです"
✅ "この判断は ADR-005 と関連しているので、Related ADRs に追加しては？"

## 避けるべきレビューコメント

❌ "この判断は間違っている"（レビューは判断の正否ではなく、記録の品質）
❌ "もっと詳しく書いて"（具体的に何を追記すべきか指摘する）
```

### 意思決定のタイミング

**ADRを書くべきタイミング**：

1. **重要な技術選定**
   - データベース、フレームワーク、言語の選択
   - ホスティング、クラウドプロバイダーの選択

2. **アーキテクチャの変更**
   - モノリス → マイクロサービス
   - 同期 → 非同期処理
   - REST → GraphQL

3. **セキュリティポリシー**
   - 認証方式の決定
   - 暗号化方式の選択

4. **開発プロセス**
   - CI/CDパイプラインの設計
   - ブランチ戦略の決定

5. **外部サービス連携**
   - 決済プロバイダーの選択
   - 監視ツールの選択

**ADRを書かなくて良いケース**：

```
❌ ライブラリのバージョンアップ（定常的な作業）
❌ バグ修正（設計判断ではない）
❌ 小さなリファクタリング（影響範囲が限定的）
❌ 一時的な実験（本番に影響しない）

ただし、これらが「重要な判断」を含む場合はADRを書く
```

## ADRツールの活用

### adr-tools（CLI）

**インストール**：

```bash
# macOS
brew install adr-tools

# Linux
git clone https://github.com/npryce/adr-tools
cd adr-tools
sudo make install
```

**基本的な使い方**：

```bash
# ADRディレクトリの初期化
adr init docs/adr

# 新しいADRの作成
adr new "Use PostgreSQL for database"
# → docs/adr/0001-use-postgresql-for-database.md が生成される

# ADRのリスト表示
adr list

# ADRの廃止
adr new -s 1 "Use MySQL instead of PostgreSQL"
# → ADR-001が Superseded になり、新しいADRが作成される
```

**生成されるADR**：

```markdown
# 1. Use PostgreSQL for database

Date: 2024-01-20

## Status

Accepted

## Context

[ここに背景を記入]

## Decision

[ここに決定を記入]

## Consequences

[ここに影響を記入]
```

### Log4brains（Webベース）

**特徴**：

- ADRをWebサイトとして表示
- ブラウザで読みやすい
- 検索、フィルタリング機能
- 静的サイト生成（GitHub Pagesで公開可能）

**インストール**：

```bash
npm install -g log4brains
```

**使い方**：

```bash
# 初期化
log4brains init

# ADRの作成
log4brains adr new

# プレビュー
log4brains preview
# → http://localhost:4004 でブラウザが開く

# 静的サイトの生成
log4brains build
# → .log4brains/out/ にHTMLが生成される
```

**GitHub Pagesでの公開**：

```yaml
# .github/workflows/log4brains.yml
name: Log4brains

on:
  push:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm install -g log4brains
      - run: log4brains build
      - uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: .log4brains/out
```

### ADR Manager（VS Code拡張機能）

**機能**：

- ADRのテンプレートからの作成
- ADRのプレビュー
- ADRのリンク補完

**インストール**：

VS Codeの拡張機能マーケットプレイスで "ADR Manager" を検索してインストール。

**使い方**：

1. コマンドパレット（Cmd+Shift+P）を開く
2. "ADR: Create new ADR" を選択
3. タイトルを入力
4. テンプレートから自動生成

## チームでのADR運用

### ADR文化の醸成

#### 1. ADRの価値を伝える

**キックオフミーティングで説明**：

```markdown
# なぜADRを導入するのか

## 問題
- 過去の設計判断の理由が分からない
- 同じ議論を繰り返している
- 新メンバーのオンボーディングに時間がかかる

## 解決策
- ADRで設計判断を記録
- 将来の自分、チームメンバーへの贈り物

## 期待される効果
- オンボーディング時間: 2週間 → 1週間
- 設計議論の効率: 50%向上
- 意思決定の透明性向上
```

#### 2. テンプレートを用意する

**チーム専用テンプレート**：

```markdown
# ADR-XXX: [タイトル]

## Status

Proposed

## Context

### 背景

### 要件

### 検討した選択肢

### 制約条件

## Decision

## Consequences

### Positive（利点）

### Negative（欠点）

### Risks（リスク）

### Trade-offs（トレードオフ）

## References

## Related ADRs
```

#### 3. ADRレビューをプロセスに組み込む

**Pull Requestテンプレート**：

```markdown
## 概要

## 変更内容

## ADRの有無

- [ ] この変更には重要な設計判断が含まれる → ADRを作成済み
- [ ] この変更は軽微で、ADRは不要

## チェックリスト

- [ ] テストを追加した
- [ ] ドキュメントを更新した
- [ ] ADRを作成した（該当する場合）
```

### ADRレビューのベストプラクティス

#### 1. レビュアーのアサイン

**推奨する体制**：

```
- 必須レビュアー: テックリード、アーキテクト
- オプションレビュアー: 関連チームのメンバー
- レビュー期限: 3営業日
```

#### 2. レビュー観点

**チェックリスト**：

```markdown
## ADRレビューチェックリスト

### 明確性
- [ ] タイトルが判断内容を適切に表している
- [ ] 専門用語が説明されている
- [ ] 判断内容が明確

### 完全性
- [ ] Contextが十分に説明されている
- [ ] 検討した選択肢がすべて列挙されている
- [ ] Consequencesが正直に書かれている
- [ ] リスクと軽減策が記載されている

### 正確性
- [ ] 技術的な記述が正確
- [ ] 情報源が明記されている
- [ ] 実測データと推測が区別されている

### 有用性
- [ ] 将来の意思決定に役立つ
- [ ] トレードオフが明確
- [ ] 見直しポイントが明記されている
```

#### 3. 非同期レビューの活用

**レビューコメントの例**：

```markdown
## レビューコメント

### Context について

> ユーザー数が10,000を超えた場合にスケーリングが必要

この「10,000」という数値の根拠を教えてください。
パフォーマンステストの結果でしょうか？
それとも一般的な目安でしょうか？

### Consequences について

MongoDB を選ばなかった理由も Consequences に追記すると、
将来的に「なぜMongoDBじゃないのか」という質問に答えられると思います。

### Related ADRs

この判断は ADR-005（キャッシュ戦略）と関連しているので、
Related ADRs に追加してはどうでしょうか？
```

### 定期的な見直し

#### 1. ADRレビューミーティング

**四半期ごとに実施**：

```markdown
# ADRレビューミーティング（2024 Q2）

## 目的
- 過去のADRが現在も有効か確認
- Deprecated すべきADRの特定
- 新しいADRが必要な領域の洗い出し

## アジェンダ

1. 前回（Q1）からの変更
2. 既存ADRのステータス確認
   - ADR-001: PostgreSQL → 継続使用中（OK）
   - ADR-002: Microservices → 移行完了（OK）
   - ADR-007: Redis → 使用中止、Deprecated に変更
3. 新しいADRが必要な領域
   - Kubernetes への移行（次回議論）
```

#### 2. ADRダッシュボード

**指標の可視化**：

```markdown
# ADRダッシュボード（2024年6月）

## 統計
- 総ADR数: 23
- Accepted: 18
- Proposed: 2
- Deprecated: 3
- Superseded: 0

## 最近の活動
- 今月の新規ADR: 2
- 今月のステータス変更: 1

## カテゴリ別
- アーキテクチャ: 8
- データベース: 5
- フロントエンド: 4
- セキュリティ: 3
- その他: 3

## 次のアクション
- ADR-021, 022 のレビュー完了（今週中）
- ADR-007 の Deprecated 処理
```

## ADRの落とし穴と対策

### よくある失敗パターン

#### 1. 詳細すぎるADR

**問題**：

```markdown
# ADR-010: データベースにPostgreSQLを採用

## Context

（50ページに渡る詳細な技術比較...）

結果：誰も読まない、メンテナンスできない
```

**対策**：

- **1〜2ページに収める**
- 詳細は別ドキュメントへのリンク
- 要点を簡潔に

**改善例**：

```markdown
# ADR-010: データベースにPostgreSQLを採用

## Context

データベース選定を行った。詳細な技術比較は
[docs/database-comparison.md](./database-comparison.md) を参照。

結論として、以下の理由でPostgreSQLを選定：
1. JSON型のサポート
2. 全文検索機能
3. チームの経験

（以下、簡潔に記載）
```

#### 2. 抽象的すぎるADR

**問題**：

```markdown
# ADR-005: スケーラビリティを向上させる

## Decision

スケーラブルなアーキテクチャにする。

結果：具体的に何をするのか不明
```

**対策**：

- **具体的な判断を記載**
- 抽象的な目標ではなく、具体的な手段

**改善例**：

```markdown
# ADR-005: Read Replica を導入してデータベースの読み取りをスケール

## Decision

PostgreSQLに Read Replica を3台追加し、
読み取りクエリを分散させる。

（以下、具体的に記載）
```

#### 3. ADRの乱立

**問題**：

```
ADR-023: ライブラリAのバージョンを1.2.3に更新
ADR-024: ライブラリBのバージョンを2.0.0に更新
ADR-025: ESLint設定を変更
...

結果：ADRの価値が薄れる、重要な判断が埋もれる
```

**対策**：

- **重要な判断のみADRにする**
- 定常的な作業はADRにしない
- 「これは本当にADRが必要か？」を自問

**判断基準**：

```markdown
## ADRを書くべきか？

以下のいずれかに当てはまる場合、ADRを書く：

1. チーム全体に影響する判断
2. 将来的に「なぜ？」と聞かれそうな判断
3. 複数の選択肢を検討した判断
4. トレードオフがある判断
5. 後から覆すのが困難な判断

それ以外は、コミットメッセージやPR説明で十分。
```

#### 4. ADRを更新してしまう

**問題**：

```bash
# ADR-001を直接編集
git commit -m "Update ADR-001 with new decision"

結果：過去の判断の履歴が失われる
```

**対策**：

- **ADRは変更しない（Immutable）**
- 新しいADRで上書き
- 古いADRのステータスを Superseded に変更

**正しいフロー**：

```bash
# 新しいADRを作成
docs/adr/0025-new-decision.md

# 古いADRのステータスを更新
docs/adr/0001-old-decision.md
## Status
Superseded by ADR-025 (2024-06-01)
```

### ADRが機能しないケース

#### 1. チームの合意がない

**症状**：

- ADRが書かれない
- レビューされない
- 無視される

**原因**：

- ADRの価値が理解されていない
- 「面倒くさい」という認識
- トップダウンで押し付けられた

**対策**：

1. **小さく始める**
   - まず1つADRを書いてみる
   - 価値を実感してもらう

2. **成功体験を共有**
   - 「ADRがあったから助かった」事例を共有
   - オンボーディングでの活用例

3. **ボトムアップで推進**
   - チームメンバーが主体的に書く
   - 強制ではなく、文化として定着

#### 2. メンテナンスされない

**症状**：

- ADRが古くなる
- Deprecated すべきものが放置
- リンクが切れている

**原因**：

- メンテナンス責任が不明
- レビューの仕組みがない

**対策**：

1. **定期的なレビュー**
   - 四半期ごとにADRレビューミーティング

2. **責任者を決める**
   - テックリードがオーナー

3. **自動化**
   - リンク切れチェック（CI）
   - 古いADRの警告

**リンク切れチェックの例**：

```yaml
# .github/workflows/check-adr-links.yml
name: Check ADR Links

on: [push, pull_request]

jobs:
  check-links:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Check links
        run: |
          # markdown-link-check などのツールを使用
          find docs/adr -name '*.md' -exec markdown-link-check {} \;
```

## まとめ

### ADRの価値

ADR（Architecture Decision Records）は、設計判断を記録するための軽量で実践的なフレームワークです。

**ADRがもたらす価値**：

1. **記憶の補完**: 過去の判断の理由が明確になる
2. **議論の効率化**: 同じ議論を繰り返さない
3. **透明性の向上**: 意思決定プロセスが可視化される
4. **オンボーディングの効率化**: 新メンバーがプロジェクトを理解しやすい
5. **知識の継承**: チームの知識が蓄積される

### ADRの基本原則

1. **軽量**: 1〜2ページに収める
2. **イミュータブル**: 一度書いたら変更しない
3. **バージョン管理**: コードと同じリポジトリで管理
4. **検索可能**: プレーンテキストで記述
5. **時系列**: 連番で履歴を追える

### 成功のポイント

1. **チームの合意**
   - ADRの価値を共有
   - ボトムアップで推進

2. **適切な粒度**
   - 重要な判断のみADRにする
   - 詳細すぎず、抽象的すぎず

3. **継続的な運用**
   - 定期的なレビュー
   - メンテナンスの仕組み

4. **ツールの活用**
   - adr-tools、Log4brainsなどで効率化

### 次のステップ

ADRを導入したら、以下のステップで運用を開始しましょう：

1. **Week 1: 準備**
   - ADRディレクトリの作成
   - テンプレートの用意
   - チームへの説明

2. **Week 2-4: 試験導入**
   - 最初の3つのADRを書く
   - レビュープロセスの確立

3. **Month 2-3: 定着**
   - チーム全体で運用
   - フィードバックを反映

4. **Quarter 1: 改善**
   - 四半期レビュー
   - プロセスの改善

ADRは、未来の自分やチームメンバーへの贈り物です。今日から始めて、プロジェクトの保守性と透明性を向上させましょう。

## チェックリスト

この章で学んだことを確認しましょう：

- [ ] ADRの目的と価値を理解している
- [ ] ADRの基本構造（Status、Context、Decision、Consequences）を説明できる
- [ ] 実践的なADRを作成できる
- [ ] ADRのディレクトリ構造と命名規則を理解している
- [ ] ADRのワークフロー（作成、レビュー、承認）を実践できる
- [ ] ADRツール（adr-tools、Log4brains）を活用できる
- [ ] チームでのADR運用方法を理解している
- [ ] ADRの落とし穴と対策を知っている
- [ ] 「重要な判断」と「ADR不要な判断」を区別できる

## 次のステップ

次の章では、コメントのベストプラクティスについて学びます。ADRがアーキテクチャレベルの判断を記録するのに対し、コメントはコードレベルの説明を提供します。どのような場合にコメントが必要で、どのような場合に不要なのか、良いコメントと悪いコメントの違いを理解していきましょう。

**関連する章**：

- 第13章: 設計判断の記録（ADRの前提となる考え方）
- 第15章: コメントのベストプラクティス（コードレベルの記録）
- 第17章: ドキュメント管理戦略（ADRの配置と管理）

**さらに学ぶために**：

- [ADR GitHub Organization](https://adr.github.io/)
- [Michael Nygard's Blog](https://cognitect.com/blog/2011/11/15/documenting-architecture-decisions)
- [Markdown Any Decision Records (MADR)](https://adr.github.io/madr/)
- [ADR Tools](https://github.com/npryce/adr-tools)
- [Log4brains](https://github.com/thomvaill/log4brains)
