---
title: "設計判断の記録"
---

# 設計判断の記録

## この章で学ぶこと

この章では、ソフトウェア開発における設計判断を記録する重要性と、その実践的な方法について学びます。コードは「何を」実装するかを示しますが、「なぜ」その設計を選択したのか、どのような選択肢を検討したのか、どんなトレードオフがあったのかは、コードだけでは伝わりません。

設計判断の記録は、未来の自分やチームメンバーへの重要なメッセージです。半年後、1年後、あるいは数年後に「なぜこうなっているのか」という問いに答えるための道標となります。また、新しいメンバーがプロジェクトに参加したとき、過去の判断の背景を理解することで、より良い貢献ができるようになります。

本章では、設計判断を記録する意義、記録すべき情報の種類、実践的な記録方法、そして記録を継続するためのポイントについて解説します。次の第14章では、より構造化された形式であるADR（Architecture Decision Records）について詳しく学びます。

**前提知識:**
- 基本的なドキュメント作成の原則（第1章）
- Markdownの基本的な文法（第4章）
- プロジェクトの構造に関する理解

---

## なぜ設計判断を記録するのか

### 記憶は薄れていく

開発中は、なぜその技術を選んだのか、なぜそのアーキテクチャにしたのか、明確に覚えています。しかし、時間が経つと記憶は薄れていきます。3ヶ月後には曖昧になり、1年後にはほとんど思い出せません。

```markdown
❌ 記録がない場合の問題:

// コードレビューで1年後...
レビュアー: 「なぜRedisを使わずにMemcachedを選んだのですか？」
開発者: 「確か...理由があったはずなんですが...」

// 結果
- 同じ議論を何度も繰り返す
- 過去の判断を無視して、同じ問題に直面する
- 最適でない技術選定をしてしまう
```

```markdown
✅ 記録がある場合:

// docs/decisions/002-cache-selection.md
# キャッシュシステムとしてMemcachedを採用

## 判断日
2025-06-15

## 状況
- APIレスポンスタイムを改善する必要がある
- 特に商品検索のキャッシュが必要
- チーム内にRedis経験者はいるがMemcached経験者はいない

## 検討した選択肢
1. Redis
2. Memcached
3. Amazon ElastiCache

## 決定内容
Memcachedを採用する

## 理由
- シンプルなkey-valueキャッシュで十分（pub/sub不要）
- メモリ使用効率がRedisより優れている
- 水平スケーリングが容易
- 学習コストは低い（1-2日で習得可能）

## トレードオフ
採用したこと:
- シンプルさ
- メモリ効率
- スケーラビリティ

諦めたこと:
- データ永続化
- 複雑なデータ構造（リスト、セットなど）
- Pub/Sub機能

## 影響
- キャッシュヒット率: 想定80%以上
- レスポンスタイム: 200ms → 50ms（想定）
- インフラコスト: 月額$100程度（想定）

// 結果
- 1年後でも判断の背景が明確
- 新しいメンバーも理解できる
- 同じ議論を繰り返さない
```

### チーム全体の理解を深める

設計判断の記録は、チーム全体で共有される知識ベースとなります。

**新メンバーのオンボーディング:**
- なぜこのアーキテクチャなのか理解できる
- 過去の試行錯誤から学べる
- より早く貢献できるようになる

**意思決定の透明性:**
- なぜその判断をしたのか説明できる
- 判断プロセスが可視化される
- チーム全体で判断の妥当性を検証できる

**一貫性の維持:**
- 同じような判断が必要な時、過去の記録を参照できる
- プロジェクト全体で一貫した方針を維持できる
- 矛盾する判断を避けられる

### 将来の変更への備え

ソフトウェアは変化します。要件が変わり、技術が進化し、チームが成長します。その時、過去の判断の記録が重要な役割を果たします。

**前提条件の変化を検出:**
```markdown
✅ 記録された前提条件の例:

## 前提条件
- 月間アクティブユーザー: 10,000人以下
- データ量: 100GB以下
- チームサイズ: 3人
- 開発期間: 3ヶ月

## 判断
単一のPostgreSQLインスタンスを使用する

---

// 1年後の状況
- 月間アクティブユーザー: 50,000人（5倍）
- データ量: 500GB（5倍）
- チームサイズ: 8人

→ 前提条件が変わったため、アーキテクチャの再検討が必要
→ 記録があるため、何が変わったのか明確
```

**技術的負債の管理:**
```markdown
✅ 技術的負債の記録例:

## 判断
ユーザー認証を自前で実装する

## 理由
- MVP段階でスピード優先
- 外部サービスのコストを削減
- シンプルなメール/パスワード認証で十分

## 既知の問題点（技術的負債）
- OAuth未対応
- 二要素認証未対応
- パスワードポリシーが緩い
- セッション管理が簡易的

## 将来の改善予定
ユーザー数が1万人を超えたら、Auth0などの専門サービスへの移行を検討する

理由:
- セキュリティ要件が高まる
- 多様な認証方式への対応が必要になる
- 専門家によるメンテナンスが望ましい

---

// この記録により
- いつ技術的負債を解消すべきか明確
- 将来のリファクタリング計画が立てやすい
- 現状の制約を新メンバーも理解できる
```

### コンテキストの保存

コードは「What（何を）」を示しますが、「Why（なぜ）」と「How we decided（どう決めたか）」は示しません。

**Whatだけの世界:**
```typescript
// config/database.ts
export const config = {
  host: 'localhost',
  port: 5432,
  database: 'myapp',
  pool: {
    min: 2,
    max: 10
  }
};
```

このコードからは以下のことがわかりません:
- なぜPostgreSQLなのか（MySQLではダメなのか）
- なぜpool maxが10なのか（5でも20でもなく）
- なぜlocalhostなのか（RDSなどのマネージドサービスではないのか）

**WhyとHowを加えた世界:**
```typescript
// config/database.ts

/**
 * データベース接続設定
 *
 * 詳細な判断の背景: docs/decisions/003-database-configuration.md
 */
export const config = {
  // PostgreSQL: docs/decisions/001-database-selection.md 参照
  host: 'localhost',
  port: 5432,
  database: 'myapp',

  // コネクションプール設定
  // 詳細: docs/decisions/005-connection-pool-sizing.md
  pool: {
    min: 2,  // アイドル時の最小接続数
    max: 10  // 負荷テストで最適と判断（8コアEC2想定）
  }
};
```

```markdown
// docs/decisions/005-connection-pool-sizing.md

# データベースコネクションプールのサイズ設定

## 判断日
2025-07-20

## 状況
- EC2インスタンス: t3.large (2 vCPU, 8GB RAM)
- 想定同時接続: 最大100リクエスト/秒
- アプリケーションサーバー: 2台

## 決定内容
- pool.min: 2
- pool.max: 10

## 理由

### 最大接続数（max: 10）の根拠
PostgreSQLの推奨設定式に基づく:
connections = (num_cores * 2) + effective_spindle_count

参考: PostgreSQL公式Wiki
https://wiki.postgresql.org/wiki/Number_Of_Database_Connections

計算:
- num_cores: 2（vCPU）
- effective_spindle_count: 1（EBS使用）
- (2 * 2) + 1 = 5

ただし、以下の理由で2倍の10に設定:
1. バースト的なトラフィックへの対応
2. アプリケーションサーバーが2台のため、1台あたり10接続
3. 将来的なスケールアップの余地

### 最小接続数（min: 2）の根拠
- アイドル時も即座にクエリ実行可能
- コネクション確立のオーバーヘッド削減
- 過剰なリソース消費は避ける

## 検討した代替案

### 案1: max: 5
メリット:
- PostgreSQL推奨値に忠実
- リソース消費が少ない

デメリット:
- バーストトラフィックで接続待ちが発生する可能性

### 案2: max: 20
メリット:
- より多くの同時接続に対応

デメリット:
- データベースサーバーへの負荷増大
- コンテキストスイッチのオーバーヘッド
- メモリ消費増加

## トレードオフ
- 接続数を増やせば同時処理能力は上がるが、DB負荷も上がる
- 少なすぎると接続待ちが発生する
- 10は両者のバランスを取った値

## モニタリング計画
以下のメトリクスを監視し、必要に応じて調整:
- 接続プールの使用率
- 接続待ちの発生頻度
- データベースのCPU使用率

CloudWatch Alarmsで以下を設定:
- プール使用率 > 80%で警告
- 接続待ち > 10秒で警告

## 将来の見直しトリガー
以下の場合、設定を再検討:
- トラフィックが2倍以上に増加
- EC2インスタンスタイプの変更
- データベースサーバーのスケールアップ
```

このように詳細な記録があれば:
- なぜこの値なのか理解できる
- 将来、値を変更すべきタイミングがわかる
- 同じような判断が必要な時、参考にできる

---

## 記録すべき情報

設計判断を記録する際、どのような情報を含めるべきでしょうか。ここでは、実践的に役立つ情報項目を紹介します。

### 基本情報

**タイトル:**
何についての判断なのか、一目でわかるタイトルをつけます。

```markdown
✅ 良いタイトル:
- データベースとしてPostgreSQLを採用
- 認証方式にJWTを使用
- フロントエンドフレームワークとしてReactを選定
- モノリシックアーキテクチャを採用

❌ 悪いタイトル:
- データベースについて
- 認証
- 技術選定
- システム設計
```

**判断日:**
いつその判断をしたのか記録します。これにより、時系列で判断を追跡できます。

```markdown
## 判断日
2025-08-15

// または

## 日付
- 提案日: 2025-08-10
- 議論日: 2025-08-12
- 決定日: 2025-08-15
- 実装日: 2025-08-20
```

**ステータス:**
判断の現在の状態を明記します。

```markdown
## ステータス
提案中 / 承認済み / 実装済み / 却下 / 廃止

// 例:
## ステータス
承認済み（2025-08-15）

## ステータス履歴
- 2025-08-10: 提案
- 2025-08-15: 承認
- 2025-09-01: 実装完了
```

### Context（状況・背景）

判断を下した時の状況や背景を詳しく記録します。これは最も重要な情報の一つです。

**問題・課題:**
```markdown
## 状況

### 解決すべき問題
現在のAPIレスポンスタイムが平均500msと遅く、ユーザー体験を損なっている。
特に商品検索APIは1秒以上かかることもあり、改善が急務。

### 現状の課題
- データベースへの問い合わせが毎回発生
- 同じクエリが何度も実行されている
- ピーク時にデータベース負荷が高い

### 制約条件
- 予算: 月額$200まで
- 開発期間: 2週間
- チームメンバー: 全員キャッシュ実装経験あり
```

**前提条件:**
```markdown
## 前提条件

### システム規模
- 月間アクティブユーザー: 5,000人
- 1日のリクエスト数: 約50,000回
- データベースサイズ: 50GB
- 商品数: 10,000点

### 技術スタック
- バックエンド: Node.js + Express
- データベース: PostgreSQL 14
- インフラ: AWS EC2 + RDS
- デプロイ: Docker

### チーム状況
- バックエンドエンジニア: 2名
- 経験レベル: Node.js 2年以上
- キャッシュ実装経験: 全員あり
```

**ビジネス要件:**
```markdown
## ビジネス要件
- 検索レスポンスタイムを200ms以下にする
- 商品情報の更新は5分以内に反映されれば良い
- ダウンタイムは最小限に抑える
- 2026年1月のキャンペーンまでに本番稼働
```

### Decision（決定内容）

何を決定したのか、明確に記述します。

```markdown
## 決定内容

商品検索APIにRedisを使用したキャッシュレイヤーを導入する。

### 具体的な実装方針
1. Redis 7.x を使用
2. キャッシュキー形式: `product:search:{query_hash}`
3. TTL（有効期限）: 300秒（5分）
4. キャッシュヒット時は即座に返却、ミス時はDBから取得してキャッシュ
5. 商品更新時は関連するキャッシュを削除

### 適用範囲
- 商品検索API（`GET /api/products/search`）
- 商品一覧API（`GET /api/products`）
- 商品詳細API（`GET /api/products/:id`）

※カート、注文などのAPIには適用しない（リアルタイム性が重要）
```

### Alternatives（検討した選択肢）

どのような選択肢を検討したのか記録します。これにより、なぜ最終的にその判断に至ったのか理解できます。

```markdown
## 検討した選択肢

### 選択肢1: Redis
メリット:
- 高速（メモリベース）
- 豊富なデータ構造
- 永続化可能
- チーム全員に経験あり

デメリット:
- メモリ消費が大きい
- 運用コストがかかる
- シングルスレッド（一部の処理）

コスト:
- AWS ElastiCache: 約$50/月（cache.t3.micro想定）

### 選択肢2: Memcached
メリット:
- シンプル
- メモリ効率が良い
- マルチスレッド

デメリット:
- データ構造がシンプル（key-valueのみ）
- 永続化不可
- チーム内に経験者なし

コスト:
- AWS ElastiCache: 約$40/月（cache.t3.micro想定）

### 選択肢3: アプリケーション内キャッシュ（Node.js memory）
メリット:
- 追加インフラ不要
- コスト$0
- シンプル

デメリット:
- サーバー再起動でキャッシュクリア
- 複数サーバー間で共有不可
- メモリ使用量の制御が難しい

### 選択肢4: CDN（CloudFront）
メリット:
- グローバルな配信
- DDoS対策にもなる

デメリット:
- API向けには過剰
- 動的コンテンツには不向き
- 設定が複雑

コスト:
- 従量課金（想定$30-100/月）
```

### Rationale（理由・根拠）

なぜその決定をしたのか、詳細な理由を記述します。

```markdown
## 決定理由

### Redisを選んだ主な理由

#### 1. パフォーマンス要件を満たす
- メモリベースで応答時間1ms以下（想定）
- 目標の200ms以下を十分に達成可能

#### 2. チームの経験
- 全員がRedis使用経験あり
- 学習コスト不要
- すぐに実装開始できる

#### 3. 将来の拡張性
検索結果のキャッシュ以外にも活用可能:
- セッション管理
- リアルタイムランキング（Sorted Set使用）
- Pub/Subでの通知機能

#### 4. 運用実績
- AWSのマネージドサービス（ElastiCache）がある
- 自動バックアップ、フェイルオーバー対応
- 豊富な監視ツール

### Memcachedを採用しなかった理由
- チーム内に経験者がいない（学習コストが発生）
- 将来の拡張性が限定的
- コスト差が小さい（$10/月程度）

### アプリケーション内キャッシュを採用しなかった理由
- サーバー増設時にキャッシュが共有されない
- デプロイのたびにキャッシュがクリアされる
- 本番環境では複数サーバー構成が必要

### 参考資料
- Redis公式ドキュメント: https://redis.io/docs/
- AWS ElastiCache ベストプラクティス: https://docs.aws.amazon.com/elasticache/
```

### Consequences（結果・影響）

この判断によってどのような結果や影響があるのか記録します。

```markdown
## 影響

### ポジティブな影響

#### パフォーマンス改善
- 検索APIレスポンスタイム: 500ms → 50ms（想定90%削減）
- キャッシュヒット率: 80%以上を目標
- データベース負荷: 80%削減（想定）

#### ユーザー体験の向上
- ページ読み込み速度の改善
- 検索結果の即座な表示
- ピーク時でも安定したレスポンス

#### 運用面
- データベースへの負荷軽減
- スケールアウトが容易
- 監視・デバッグツールが充実

### ネガティブな影響（トレードオフ）

#### コスト増加
- インフラコスト: 月額$50増
- 年間: $600の追加コスト
- ただし、ユーザー体験向上による売上増で相殺可能（想定）

#### 運用複雑性
- キャッシュの整合性管理が必要
- 監視対象が増える（Redis自体の監視）
- デバッグ時にキャッシュの状態確認が必要

#### データ整合性リスク
- 最大5分間は古いデータが返る可能性
- ただし、商品情報は頻繁に変更されないため許容範囲

### 必要なアクション

#### 実装前
- [ ] Redis環境のセットアップ（開発・ステージング・本番）
- [ ] キャッシュ戦略の詳細設計
- [ ] テストシナリオの作成

#### 実装中
- [ ] キャッシュレイヤーの実装
- [ ] 単体テスト・統合テストの実装
- [ ] パフォーマンステスト

#### 実装後
- [ ] モニタリングダッシュボードの作成
- [ ] アラート設定
- [ ] 運用ドキュメントの作成
- [ ] チームへの共有会

#### 継続的な監視項目
- キャッシュヒット率
- レスポンスタイム
- Redis メモリ使用率
- エラー率
```

### 将来の検討事項

```markdown
## 将来の検討事項

### 見直しトリガー
以下の条件に該当する場合、この判断を再検討する:

1. **ユーザー数の大幅増加**
   - 月間アクティブユーザーが50,000人を超えた場合
   - Redisのメモリが不足する場合
   - → Redis Clusterへの移行を検討

2. **データ整合性要件の変更**
   - 商品情報をリアルタイムに反映する必要が出た場合
   - → TTLの短縮、またはイベント駆動型の更新を検討

3. **コスト最適化の要求**
   - インフラコスト削減が求められた場合
   - → Memcachedへの移行、またはキャッシュ戦略の見直し

### 改善の余地
- キャッシュウォーミング（事前にキャッシュを生成）
- よりインテリジェントなTTL設定（商品の更新頻度に応じて変更）
- 多層キャッシュ（ブラウザキャッシュ + Redis）

### 関連する今後の判断
- セッション管理の方法（Redisを活用できる）
- リアルタイム機能の実装（Pub/Sub活用）
```

---

## 記録のタイミング

いつ設計判断を記録すべきでしょうか。理想的なタイミングと実践的なアプローチを紹介します。

### 判断を下した直後

**最も重要なタイミングです。** 判断を下した直後は、背景や理由が最も鮮明に記憶に残っています。

```markdown
✅ 推奨されるフロー:

1. 技術選定会議
   ↓
2. 判断を記録（30分以内）
   ↓
3. チームで共有
   ↓
4. 実装開始

// 判断を記録するための時間を確保
会議の最後10-15分を記録作成に充てる
または
会議後すぐに担当者が記録を作成する
```

**実践的な例:**
```markdown
// チーム会議の議事録テンプレート

## 技術選定会議 2025-08-15

### 議題
商品検索APIのパフォーマンス改善

### 参加者
- 田中（バックエンド）
- 佐藤（バックエンド）
- 鈴木（インフラ）

### 議論内容
[省略]

### 決定事項
Redisを使用したキャッシュレイヤーを導入する

### アクション
- [ ] 田中: 決定内容を docs/decisions/010-redis-cache.md に記録（本日中）
- [ ] 佐藤: Redis環境のセットアップ（明日から）
- [ ] 鈴木: インフラコスト見積もり（今週中）

---

// その日のうちに記録を作成
// docs/decisions/010-redis-cache.md
[詳細な記録...]
```

### 重要な判断の前

判断を下す前に、検討プロセスを記録することも有効です。

```markdown
## ステータス: 検討中

## 検討する判断
商品検索APIのパフォーマンス改善方法

## 候補
1. Redis
2. Memcached
3. アプリケーション内キャッシュ

## 評価基準
- パフォーマンス
- コスト
- チームの習熟度
- 将来の拡張性

## 次のステップ
- 各候補の詳細調査（担当: 田中、期限: 8/12）
- チーム会議で決定（8/15）

---

// 会議後、決定内容を追記
## ステータス: 承認済み（2025-08-15）

## 決定内容
Redisを採用
[詳細...]
```

### 実装完了時

実装が完了した時に、実際の結果を記録に追記します。

```markdown
## 実装結果（2025-09-01追記）

### 実測値

#### パフォーマンス
- 検索APIレスポンスタイム:
  - Before: 平均485ms（実測）
  - After: 平均42ms（実測）
  - 改善率: 91%

- キャッシュヒット率: 83%（実測、1週間の平均）
- データベースクエリ削減: 78%（実測）

#### コスト
- AWS ElastiCache (cache.t3.micro): $52.56/月（実測）
- 想定$50とほぼ同じ

### 実装時の課題と解決策

#### 課題1: キャッシュの削除タイミング
問題:
商品更新時に関連する検索キャッシュをすべて削除する必要があるが、
検索クエリのパターンが無限にある

解決策:
- タグベースのキャッシュ削除を実装
- 商品IDをタグとして保存
- 商品更新時、そのIDを含むキャッシュをまとめて削除

参考実装: src/cache/tags.ts

#### 課題2: メモリ使用量の予測
問題:
実際のキャッシュサイズが想定より大きかった

解決策:
- 検索結果を圧縮して保存（gzip）
- メモリ使用量: 約60%削減
- レスポンスタイムへの影響: 5ms程度の増加（許容範囲）

### 学んだこと
- キャッシュキーの設計は慎重に（後から変更が困難）
- メモリ使用量は実測が重要（想定の2倍だった）
- 段階的なロールアウトが有効（カナリアリリース）

### 今後の改善予定
- [ ] キャッシュウォーミングの実装（優先度: 中）
- [ ] 検索クエリの正規化（優先度: 低）
```

### 判断を変更する時

過去の判断を変更する場合、その理由と経緯を記録します。

```markdown
## ステータス変更履歴

### 2025-08-15: 承認
Redisを使用したキャッシュレイヤーを導入

### 2026-01-15: 一部変更
検索API以外にも適用範囲を拡大

---

## 変更内容（2026-01-15追記）

### 状況の変化
- 月間アクティブユーザー: 5,000人 → 45,000人
- 商品検索以外のAPIもレスポンスタイム悪化
- キャッシュの運用ノウハウが蓄積

### 変更した判断
以下のAPIにもRedisキャッシュを適用:
- カテゴリ一覧API
- ブランド一覧API
- おすすめ商品API

### 理由
- 検索APIでの成功実績
- チーム全員がRedis運用に慣れた
- インフラコストに余裕（現在$52、上限$200）

### 影響
- 予想コスト増: $20/月程度
- 全体的なユーザー体験向上を期待
```

### 記録しないことを決めた時

すべての判断を記録する必要はありません。記録しないことを決めた場合も、その基準を明確にしておきます。

```markdown
// プロジェクトのドキュメント方針

## 設計判断の記録基準

### 記録する判断
以下のいずれかに該当する判断は必ず記録:

1. **アーキテクチャに関わる判断**
   - フレームワーク・ライブラリの選定
   - データベースの選択
   - デプロイ方法

2. **後から変更が困難な判断**
   - データモデルの設計
   - API設計の基本方針
   - 認証・認可の仕組み

3. **コストに影響する判断**
   - インフラ構成
   - 外部サービスの選定
   - スケーリング戦略

4. **複数の選択肢を検討した判断**
   - 比較検討したもの
   - 意見が分かれたもの

5. **チーム全体に影響する判断**
   - コーディング規約
   - ディレクトリ構成
   - 開発フロー

### 記録しない判断
以下は記録不要（コードとコメントで十分）:

1. **実装の詳細**
   - 変数名の命名
   - 簡単なヘルパー関数の実装方法
   - UIの細かいスタイリング

2. **明白な判断**
   - ベストプラクティスに従った標準的な実装
   - 公式ドキュメント通りの設定

3. **試行錯誤が前提の判断**
   - UIの細かいデザイン
   - パフォーマンスチューニングの試行

ただし、試行錯誤の結果、重要な学びがあれば記録する
```

---

## 実践的な記録方法

設計判断を実際にどのように記録するか、具体的な方法とツールを紹介します。

### Markdownファイルでの記録

最もシンプルで広く使われている方法です。

**基本的なディレクトリ構成:**
```
project/
├── docs/
│   ├── decisions/
│   │   ├── README.md              # インデックス
│   │   ├── 001-database-selection.md
│   │   ├── 002-cache-strategy.md
│   │   ├── 003-authentication.md
│   │   └── template.md            # テンプレート
│   ├── architecture/
│   └── api/
├── src/
└── README.md
```

**テンプレートの例:**
```markdown
// docs/decisions/template.md

# [連番]-[短いタイトル]

## ステータス
[提案中 / 承認済み / 実装済み / 却下 / 廃止]

## 判断日
YYYY-MM-DD

## 状況

### 解決すべき問題
[何が問題なのか]

### 制約条件
[予算、期間、技術的制約など]

### 前提条件
[システム規模、技術スタック、チーム状況など]

## 決定内容
[何を決めたのか]

## 検討した選択肢

### 選択肢1: [名前]
メリット:
-

デメリット:
-

### 選択肢2: [名前]
メリット:
-

デメリット:
-

## 決定理由
[なぜその判断をしたのか]

## 影響

### ポジティブな影響
-

### ネガティブな影響（トレードオフ）
-

## 必要なアクション
- [ ] 実装前
- [ ] 実装中
- [ ] 実装後

## 将来の検討事項
[どういう時に見直すか]

## 参考資料
- [関連ドキュメントやURL]
```

**インデックスファイルの例:**
```markdown
// docs/decisions/README.md

# 設計判断の記録

このディレクトリには、プロジェクトの重要な設計判断を記録しています。

## アクティブな判断

| No | タイトル | 日付 | ステータス |
|----|---------|------|-----------|
| 003 | [認証方式にJWT採用](./003-authentication.md) | 2025-08-20 | 実装済み |
| 002 | [キャッシュ戦略](./002-cache-strategy.md) | 2025-08-15 | 実装済み |
| 001 | [データベースにPostgreSQL採用](./001-database-selection.md) | 2025-07-10 | 実装済み |

## 廃止された判断

| No | タイトル | 日付 | 廃止理由 |
|----|---------|------|---------|
| - | - | - | - |

## テンプレート

新しい判断を記録する際は [template.md](./template.md) を使用してください。

## ガイドライン

### 記録すべき判断
- アーキテクチャに関わる判断
- 後から変更が困難な判断
- コストに影響する判断
- 複数の選択肢を検討した判断

### 命名規則
`[連番3桁]-[kebab-case-title].md`

例: `001-database-selection.md`

### 更新ルール
- 新しい情報が得られたら随時更新
- 実装完了時に結果を追記
- 判断を変更する場合は履歴を残す
```

### Gitでのバージョン管理

設計判断の記録もコードと同様に、Gitでバージョン管理します。

**コミットメッセージの例:**
```bash
# 新しい判断を追加
git add docs/decisions/004-api-versioning.md
git commit -m "docs: add decision record for API versioning strategy"

# 既存の判断を更新
git add docs/decisions/002-cache-strategy.md
git commit -m "docs: update cache strategy decision with implementation results"

# 判断を廃止
git add docs/decisions/005-deprecated.md
git commit -m "docs: deprecate microservices decision, returning to monolith"
```

**履歴の活用:**
```bash
# 特定の判断がいつ追加されたか確認
git log --follow docs/decisions/001-database-selection.md

# 判断の変更履歴を確認
git log -p docs/decisions/001-database-selection.md

# 特定の時点での判断内容を確認
git show main@{2025-08-01}:docs/decisions/001-database-selection.md
```

### Pull Requestでのレビュー

設計判断もコードレビューと同様に、Pull Requestでレビューします。

```markdown
✅ PR作成の例:

# PR: Redisキャッシュレイヤーの導入

## 概要
商品検索APIのパフォーマンス改善のため、Redisキャッシュレイヤーを導入します。

## 変更内容
- 設計判断の記録を追加（`docs/decisions/010-redis-cache.md`）
- キャッシュレイヤーの実装
- テストコード

## レビューポイント

### 設計判断について
- [ ] 判断の背景は明確か
- [ ] 検討した選択肢は十分か
- [ ] トレードオフは適切に記述されているか
- [ ] 将来の見直し基準は明確か

### 実装について
- [ ] 設計判断に沿った実装か
- [ ] テストは十分か

## 参考資料
- [設計判断の記録](docs/decisions/010-redis-cache.md)
- [Redis公式ドキュメント](https://redis.io/docs/)
```

**レビューコメントの例:**
```markdown
// レビュアーからのコメント

> ## 決定理由
> Redisを選んだ主な理由は...

👍 理由が明確で良いですね。

一点確認したいのですが、将来ユーザー数が10倍になった場合の
スケーリング戦略についても記載しておくと良いかもしれません。
Redis Clusterへの移行など。

---

> ### ネガティブな影響
> - データ整合性リスク
>   - 最大5分間は古いデータが返る可能性

この点、ビジネス側とも確認済みでしょうか？
商品の在庫状況など、リアルタイム性が重要なものもあるかもしれません。

---

// 作成者からの返信

> ビジネス側とも確認済みでしょうか？

良い指摘ありがとうございます！
PdM の山田さんに確認したところ、以下の回答でした:

- 商品情報（名前、説明など）は5分遅延OK
- 在庫状況はリアルタイム必須

在庫APIはキャッシュ対象外とすることを、判断記録に追記しました。
```

### ツールの活用

設計判断の記録を支援するツールも存在します。

**ADR（Architecture Decision Records）ツール:**
```bash
# adr-toolsのインストール
npm install -g adr-log

# ADRディレクトリの初期化
adr init docs/decisions

# 新しいADRの作成
adr new "Use Redis for caching"
# → docs/decisions/0001-use-redis-for-caching.md が作成される

# ADRの一覧生成
adr generate toc > docs/decisions/README.md
```

**Log4brainsの例:**
```bash
# Log4brainsのインストール（より高機能なADRツール）
npm install -g log4brains

# 初期化
log4brains init

# 新しいADRの作成（インタラクティブ）
log4brains adr new

# WebUIの起動
log4brains preview
# → http://localhost:4004 でADRを閲覧可能
```

ただし、ツールは補助的なものです。最も重要なのは:
1. 継続的に記録すること
2. チーム全体で共有すること
3. 実際に参照されること

シンプルなMarkdownファイルでも、適切に運用すれば十分効果的です。

---

## 記録の実例

実際の設計判断の記録例をいくつか紹介します。

### 例1: データベース選定

```markdown
# 001-database-selection

# データベースとしてPostgreSQLを採用

## ステータス
実装済み（2025-07-15）

## 判断日
2025-07-10

## 状況

### 解決すべき問題
新規Webアプリケーションのデータベースを選定する必要がある。

### 要件
1. **データ要件**
   - ユーザー情報、商品情報、注文情報を管理
   - 複雑なリレーションシップ（多対多含む）
   - トランザクション整合性が重要

2. **パフォーマンス要件**
   - 初期: 1,000ユーザー、10,000商品
   - 1年後想定: 10,000ユーザー、100,000商品
   - 検索機能が重要（全文検索含む）

3. **運用要件**
   - バックアップ・リストア必須
   - 本番環境: AWS
   - 開発: ローカル環境（Docker）

### 制約条件
- 予算: データベースコストは月額$200まで
- 期間: 選定から実装まで1週間
- チーム: PostgreSQL経験者2名、MySQL経験者1名

### 技術スタック
- バックエンド: Node.js + Express + TypeScript
- ORM: 未定（Prisma or TypeORM検討中）

## 決定内容

**PostgreSQL 14 を採用する**

具体的には:
- 本番環境: AWS RDS for PostgreSQL
- 開発環境: Docker (postgres:14-alpine)
- 接続プーリング: pgBouncer（必要に応じて導入）

## 検討した選択肢

### 選択肢1: PostgreSQL
**メリット:**
- 完全なACID準拠
- 豊富なデータ型（JSON、配列、全文検索用型など）
- 優れたJSON処理性能（商品の属性データに活用可能）
- 全文検索機能内蔵（拡張機能 pg_trgm使用）
- 地理空間データ対応（PostGIS）- 将来の店舗検索に活用可能
- 強力なインデックス機能（B-tree, Hash, GiST, GINなど）
- AWS RDS, Azure Databaseなどマネージドサービス充実

**デメリット:**
- MySQLに比べてチューニングが複雑（一部）
- レプリケーション設定がやや複雑

**チームの習熟度:**
- 2名がPostgreSQL経験あり（1年以上）
- 学習リソース豊富

**コスト（AWS RDS想定）:**
- db.t3.micro: $15/月
- db.t3.small: $30/月（本番想定）
- 自動バックアップ込み

**参考:**
- PostgreSQL公式: https://www.postgresql.org/
- AWS RDS: https://aws.amazon.com/rds/postgresql/

### 選択肢2: MySQL
**メリット:**
- 広く使われている（情報が豊富）
- シンプルな設定
- レプリケーションが容易
- チーム内に経験者あり（1名）

**デメリット:**
- JSON処理性能がPostgreSQLに劣る
- 全文検索機能が限定的
- データ型の柔軟性が低い

**コスト:**
- PostgreSQLとほぼ同じ

### 選択肢3: MongoDB
**メリット:**
- スキーマレス（柔軟性が高い）
- JSON-likeなドキュメント形式
- 水平スケーリングが容易

**デメリット:**
- トランザクション処理が弱い（バージョン4.0以降改善）
- リレーショナルなデータモデルには不向き
- チーム内に経験者なし
- ORMの選択肢が限定的

**コスト:**
- MongoDB Atlas: $57/月〜（M10クラスタ）
- 高い

### 選択肢4: DynamoDB
**メリット:**
- フルマネージド（運用負荷最小）
- 自動スケーリング
- AWSとの統合

**デメリット:**
- NoSQL（リレーショナルデータには不向き）
- 複雑なクエリが困難
- ベンダーロックイン
- チーム内に経験者なし

**コスト:**
- 従量課金（予測困難）

## 決定理由

### PostgreSQLを選んだ主な理由

#### 1. 要件との適合性が最も高い
- **リレーショナルデータ**: ユーザー、商品、注文の関係を自然にモデリング
- **トランザクション整合性**: 注文処理で必須
- **全文検索**: pg_trgm拡張で実現可能（別途検索エンジン不要）
- **JSON対応**: 商品の属性データ（サイズ、色など）を柔軟に管理

#### 2. チームの生産性
- 2名がPostgreSQL経験あり → すぐに開発開始可能
- 1名はMySQL経験 → PostgreSQLへの移行は容易
- 豊富な学習リソース

#### 3. 将来の拡張性
現時点では不要だが、将来活用できる機能:
- PostGIS: 店舗検索、配送エリア管理
- パーティショニング: データ量増加時のパフォーマンス維持
- 論理レプリケーション: レポート用DBの構築

#### 4. コスト
- 月額$30程度（本番環境）
- 予算$200に対して十分な余裕
- スケールアップも予算内で可能

#### 5. 運用実績
- AWS RDSで自動バックアップ、自動パッチ適用
- モニタリングツール（CloudWatch）
- 99.95%の可用性SLA

### MySQLを選ばなかった理由
- JSON処理性能でPostgreSQLに劣る
- 全文検索機能が限定的
- コスト差がほぼない
- PostgreSQLのメリットを享受できない

### MongoDBを選ばなかった理由
- リレーショナルデータモデルに不適合
- チーム内に経験者なし（学習コスト大）
- コストが高い
- トランザクション処理への不安

### DynamoDBを選ばなかった理由
- NoSQLはリレーショナルデータに不向き
- 複雑なクエリが困難
- ベンダーロックインのリスク
- チーム内に経験者なし

## 影響

### ポジティブな影響

#### 開発効率
- チームの経験を活かせる
- すぐに開発開始可能
- ORM（Prisma、TypeORM）のサポート充実

#### 機能面
- 全文検索を追加サービスなしで実現
- JSON型で柔軟なデータモデリング
- 将来の地理空間機能に対応可能

#### 運用面
- AWS RDSによる自動化（バックアップ、パッチ適用）
- 確立された監視・運用手法
- 豊富なトラブルシューティング情報

#### コスト
- 予算内で十分な性能
- スケールアップの余地あり

### ネガティブな影響（トレードオフ）

#### 学習コスト
- 1名はMySQL経験のみ → PostgreSQL固有機能の学習必要
- ただし、基本的なSQLは共通のため影響は限定的

#### チューニング
- 高度なパフォーマンスチューニングは専門知識が必要
- ただし、初期段階では不要

#### ロックイン
- PostgreSQL固有機能（配列型、JSON型など）を使うと移行困難
- ただし、データベース移行の予定なし

## 必要なアクション

### 実装前
- [x] AWS RDSインスタンスのセットアップ（dev, staging, prod）
- [x] Docker Composeファイルの作成（ローカル開発用）
- [x] 接続情報の環境変数管理
- [x] ORMの選定（Prisma vs TypeORM）

### 実装中
- [x] データベーススキーマ設計
- [x] マイグレーションスクリプト
- [x] 初期データ投入スクリプト

### 実装後
- [x] バックアップ戦略の確認
- [x] モニタリング設定（CloudWatch）
- [x] アラート設定（接続数、CPU使用率など）

## 将来の検討事項

### 見直しトリガー
以下の場合、この判断を再検討:

1. **パフォーマンス問題**
   - クエリレスポンスが1秒を超える
   - データベースCPU使用率が常時80%以上
   - → インデックス最適化、スケールアップ、リードレプリカ追加を検討

2. **データ量の大幅増加**
   - テーブルサイズが1TB超
   - → パーティショニング、シャーディングを検討

3. **コスト問題**
   - データベースコストが月$500超
   - → コスト最適化、代替案の検討

### 今後の最適化
- インデックス戦略の精緻化（実運用データに基づく）
- クエリパフォーマンスのモニタリングと改善
- 接続プールサイズの最適化

### 関連する判断
- [002-cache-strategy.md] - キャッシュ戦略（データベース負荷軽減）
- [007-orm-selection.md] - ORM選定

## 参考資料
- PostgreSQL公式ドキュメント: https://www.postgresql.org/docs/14/
- AWS RDS for PostgreSQL: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_PostgreSQL.html
- PostgreSQL vs MySQL比較: https://www.postgresql.org/about/featurematrix/
```

### 例2: 認証方式の選定

```markdown
# 003-authentication-strategy

# 認証方式にJWT（JSON Web Token）を採用

## ステータス
実装済み（2025-08-25）

## 判断日
2025-08-20

## 状況

### 解決すべき問題
Webアプリケーションのユーザー認証方式を決定する必要がある。

### 要件

**機能要件:**
- ユーザーログイン・ログアウト
- 認証状態の保持
- APIへのアクセス制御
- 将来的にモバイルアプリも対応予定

**非機能要件:**
- セキュリティ: 業界標準レベル
- パフォーマンス: 認証チェックのオーバーヘッド最小化
- スケーラビリティ: サーバー追加時の対応容易
- 開発効率: チームが実装可能

### 制約条件
- 開発期間: 2週間
- セキュリティ監査: 社内レビューのみ（外部監査なし）
- チーム: JWT経験者2名、セッション経験者3名

### システム構成
- フロントエンド: React SPA
- バックエンド: Node.js + Express
- インフラ: AWS EC2（複数インスタンス想定）
- データベース: PostgreSQL

## 決定内容

**JWT（JSON Web Token）を使用した認証を採用**

具体的な実装方針:
- ライブラリ: jsonwebtoken (npm)
- トークン種類: Access Token + Refresh Token
- Access Token有効期限: 15分
- Refresh Token有効期限: 7日
- 保存場所:
  - Access Token: メモリ（Reactステート）
  - Refresh Token: HttpOnly Cookie
- 署名アルゴリズム: RS256（非対称鍵）

## 検討した選択肢

### 選択肢1: JWT（JSON Web Token）
**メリット:**
- ステートレス（サーバー側でセッション管理不要）
- スケーラビリティが高い（サーバー追加が容易）
- モバイルアプリ対応が容易
- マイクロサービスアーキテクチャに適合
- 業界標準（多くの実装例がある）

**デメリット:**
- トークンの無効化が困難（有効期限まで有効）
- ペイロードサイズが大きい（Cookie比較）
- 実装の複雑さ（Refresh Tokenの管理など）

**セキュリティ考慮事項:**
- XSS対策: Access TokenはlocalStorageに保存しない
- CSRF対策: Refresh TokenはHttpOnly Cookieで保護
- トークンの盗難対策: 短い有効期限 + Refresh Token

**実装コスト:**
- 学習コスト: 低（チーム内に経験者あり）
- 実装工数: 5-7日（想定）

### 選択肢2: セッションベース認証
**メリット:**
- 実装がシンプル
- トークンの即座な無効化が可能
- チーム全員に経験あり

**デメリット:**
- ステートフル（セッションストア必要）
- スケーラビリティの課題（セッション共有が必要）
- モバイルアプリ対応がやや複雑

**実装方法の候補:**
- express-session + connect-redis
- セッションストア: Redis

**実装コスト:**
- 学習コスト: なし
- 実装工数: 3-5日
- インフラコスト: Redis追加（月$50程度）

### 選択肢3: OAuth 2.0 + 外部サービス（Auth0など）
**メリット:**
- 専門家によるセキュリティ
- ソーシャルログイン対応
- 二要素認証などの高度な機能
- 実装工数削減

**デメリット:**
- 外部サービス依存
- コストが高い
- カスタマイズ性が限定的

**コスト:**
- Auth0: $240/年〜（MAU 7,000まで）
- 初期段階では過剰

### 選択肢4: Firebase Authentication
**メリット:**
- 簡単な実装
- フロントエンドから直接利用可能
- 無料枠が大きい

**デメリット:**
- Google依存
- バックエンド実装の制約
- カスタマイズ性が限定的

**コスト:**
- 無料枠: MAU 50,000まで
- 以降: $0.0055/MAU

## 決定理由

### JWTを選んだ主な理由

#### 1. スケーラビリティ
- ステートレス設計 → サーバー追加が容易
- セッションストア（Redis）不要 → インフラシンプル
- ロードバランサーでのセッション固定不要

将来的なスケーリング例:
```
現在: EC2 x 2台
将来: EC2 x 10台（オートスケーリング）
→ JWTならシームレスに対応可能
```

#### 2. モバイルアプリ対応
来年予定のモバイルアプリでも同じ認証基盤を使用可能:
- iOSアプリ: Keychain に Refresh Token保存
- Androidアプリ: Keystore に Refresh Token保存
- WebとAPIを共通化

#### 3. チームの経験
- 2名がJWT実装経験あり
- 残り3名も学習容易（セッションベースとの差分は小さい）
- 豊富な実装例・ライブラリ

#### 4. コスト
- 追加インフラ不要（セッションストアなし）
- 外部サービス不要
- 実装は自社で完結

#### 5. 柔軟性
- マイクロサービス化への対応が容易
- 将来的なAPI公開も視野に入る

### セッションベースを選ばなかった理由
- スケーラビリティの懸念
  - セッション共有のためRedis必要
  - サーバー追加時の複雑さ
- モバイルアプリ対応がやや複雑

### Auth0を選ばなかった理由
- 初期段階でコスト過剰
- ユーザー数が少ない（想定1,000ユーザー）
- カスタマイズ要件がシンプル
- ただし、将来的には検討の余地あり

### Firebase Authenticationを選ばなかった理由
- Google依存のリスク
- バックエンドの制約
- チームのNode.js + PostgreSQL構成と相性悪い

## 影響

### ポジティブな影響

#### パフォーマンス
- 認証チェックのオーバーヘッド最小（トークン検証のみ）
- データベースクエリ不要（セッション取得なし）
- 想定: 認証チェック 1ms未満

#### スケーラビリティ
- サーバー追加が容易（設定不要）
- ロードバランサー設定がシンプル
- 水平スケーリングに最適

#### 開発効率
- フロントエンド・バックエンド分離
- API開発がシンプル
- テストが容易（トークンをモック可能）

### ネガティブな影響（トレードオフ）

#### セキュリティ考慮事項
**トークン無効化の困難さ:**
- ログアウト後もAccess Tokenは有効期限まで有効
- 対策: 短い有効期限（15分）+ ブラックリスト（必要時）

**実装の複雑さ:**
- Refresh Token のローテーション
- XSS/CSRF対策が必要
- 鍵管理（RS256の秘密鍵）

#### 実装工数
- セッションベースより2-3日長い
- ただし、長期的にはメンテナンスコスト削減

## 実装詳細

### トークン構造

**Access Token:**
```json
{
  "header": {
    "alg": "RS256",
    "typ": "JWT"
  },
  "payload": {
    "sub": "user_123",
    "email": "user@example.com",
    "role": "user",
    "iat": 1693324800,
    "exp": 1693325700
  }
}
```

**Refresh Token:**
```json
{
  "header": {
    "alg": "RS256",
    "typ": "JWT"
  },
  "payload": {
    "sub": "user_123",
    "type": "refresh",
    "iat": 1693324800,
    "exp": 1693929600
  }
}
```

### 鍵管理
- RS256（非対称鍵）を使用
- 秘密鍵: AWS Secrets Managerで管理
- 公開鍵: アプリケーションに埋め込み
- 鍵のローテーション: 6ヶ月ごと

### セキュリティ対策

**XSS対策:**
- Access TokenはlocalStorageに保存しない
- メモリ（Reactステート）のみに保持
- ページリロード時はRefresh Tokenで再取得

**CSRF対策:**
- Refresh TokenはHttpOnly Cookieで保護
- SameSite属性: Strict

**トークン盗難対策:**
- Access Token: 短い有効期限（15分）
- Refresh Token: ローテーション（使用後は新しいトークン発行）
- 異常なアクセスパターンの検知（TODO）

## 必要なアクション

### 実装前
- [x] JWT ライブラリの選定（jsonwebtoken）
- [x] 鍵ペアの生成
- [x] AWS Secrets Manager設定
- [x] セキュリティレビュー（社内）

### 実装中
- [x] 認証ミドルウェアの実装
- [x] ログイン・ログアウトエンドポイント
- [x] Refresh Tokenエンドポイント
- [x] フロントエンド認証ロジック
- [x] テストコード

### 実装後
- [x] セキュリティテスト
- [x] 負荷テスト
- [x] ドキュメント作成
- [x] チームへの共有会

### 継続的な監視
- トークン発行数
- 認証失敗率
- 異常なアクセスパターン

## 実装結果（2025-08-25追記）

### パフォーマンス
- 認証チェック: 平均0.5ms（実測）
- ログインAPI: 平均150ms（実測）
- トークン更新: 平均80ms（実測）

### セキュリティ
- 社内セキュリティレビュー合格
- 脆弱性スキャン: 問題なし
- ペネトレーションテスト: 実施予定（9月）

### 実装時の課題

**課題1: Refresh Tokenのローテーション**
問題:
同時リクエストで複数のRefresh Tokenが発行される可能性

解決策:
- データベースでRefresh Tokenの使用状態を管理
- 既に使用されたトークンは拒否
- 参考実装: src/auth/refresh-token-manager.ts

**課題2: フロントエンドでのトークン管理**
問題:
ページリロード時にAccess Tokenが失われる

解決策:
- アプリ起動時にRefresh Tokenで自動再取得
- ローディング状態の管理
- 参考実装: src/hooks/useAuth.ts

### 学んだこと
- トークンの有効期限設定は慎重に（短すぎると UX 悪化）
- セキュリティとユーザー体験のバランスが重要
- エラーハンドリングが複雑（トークン期限切れ、無効など）

## 将来の検討事項

### 見直しトリガー
以下の場合、この判断を再検討:

1. **セキュリティ要件の強化**
   - 金融系機能の追加
   - PCI DSS準拠が必要
   - → Auth0などの専門サービス検討

2. **ユーザー数の大幅増加**
   - MAU 50,000以上
   - → トークンブラックリストのスケーラビリティ検証

3. **複雑な認証要件**
   - 二要素認証
   - 生体認証
   - → 外部サービス（Auth0、Firebase）の検討

### 今後の改善
- [ ] トークンブラックリスト機能（緊急時用）
- [ ] デバイス管理機能（ログイン中デバイス一覧）
- [ ] 異常アクセス検知の強化

## 参考資料
- JWT公式: https://jwt.io/
- RFC 7519 (JWT): https://datatracker.ietf.org/doc/html/rfc7519
- OWASP JWT Cheat Sheet: https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html
- Auth0 JWT Handbook: https://auth0.com/resources/ebooks/jwt-handbook
```

### 例3: モノリシックアーキテクチャの選択

```markdown
# 005-architecture-monolith

# モノリシックアーキテクチャを採用

## ステータス
実装済み（2025-07-20）

## 判断日
2025-07-15

## 状況

### 解決すべき問題
新規Webアプリケーションのアーキテクチャを決定する必要がある。

### プロジェクト概要
- プロダクト: ECサイト（MVP段階）
- 機能: 商品閲覧、検索、カート、注文、決済
- 想定ユーザー: 初年度10,000人
- チーム: 3名（全員バックエンドエンジニア）
- 期間: MVP開発3ヶ月、以降も継続開発

### 要件

**機能要件:**
- ユーザー管理
- 商品管理
- カート・注文管理
- 決済処理（Stripe連携）
- メール通知

**非機能要件:**
- 可用性: 99%以上
- レスポンスタイム: 1秒以内（95パーセンタイル）
- 同時接続: 100ユーザー程度

### 制約条件
- 開発期間: 3ヶ月でMVPリリース
- チームサイズ: 3名（経験: Node.js 2年以上、マイクロサービス経験なし）
- インフラ予算: 月$500まで

## 決定内容

**モノリシックアーキテクチャを採用する**

具体的には:
- 単一のNode.js + Expressアプリケーション
- 単一のPostgreSQLデータベース
- 機能ごとにモジュール分割（内部モジュラーモノリス）
- 明確なレイヤー分離（Controller → Service → Repository）

構成:
```
src/
├── modules/
│   ├── users/
│   │   ├── user.controller.ts
│   │   ├── user.service.ts
│   │   ├── user.repository.ts
│   │   └── user.model.ts
│   ├── products/
│   ├── orders/
│   └── payments/
├── shared/
│   ├── middlewares/
│   ├── utils/
│   └── types/
└── app.ts
```

## 検討した選択肢

### 選択肢1: モノリシックアーキテクチャ
**メリット:**
- シンプルな開発・デプロイ
- デバッグが容易
- トランザクション管理が容易（単一DB）
- 小規模チームに適している
- インフラコストが低い
- 開発速度が速い

**デメリット:**
- 将来的なスケーリングの制約
- 全体のデプロイが必要（部分デプロイ不可）
- 技術スタックの統一が必要

**想定インフラコスト:**
- EC2 (t3.medium x 2): $60/月
- RDS (db.t3.small): $30/月
- ALB: $20/月
- 合計: 約$110/月

### 選択肢2: マイクロサービスアーキテクチャ
**メリット:**
- サービスごとに独立してスケール可能
- 技術スタックの柔軟性
- 障害の影響範囲が限定的
- チームの独立性

**デメリット:**
- 開発の複雑さが大幅に増加
- サービス間通信のオーバーヘッド
- 分散トランザクション管理が困難
- インフラコストが高い
- デバッグが困難
- 小規模チームには過剰

**想定インフラコスト:**
- サービスごとのEC2/ECS: $200/月以上
- API Gateway: $50/月
- サービスディスカバリ: $20/月
- 合計: $270/月以上

**実装工数:**
- サービス分割設計: 2週間
- サービス間通信実装: 2週間
- インフラ構築: 2週間
- 合計: 6週間の追加工数

### 選択肢3: サーバーレス（AWS Lambda + API Gateway）
**メリット:**
- 自動スケーリング
- 従量課金（低トラフィック時はコスト削減）
- サーバー管理不要

**デメリット:**
- コールドスタート問題
- ステートレス制約
- 実行時間制限（15分）
- チームに経験なし
- デバッグが困難

**想定コスト:**
- 低トラフィック時: $20/月程度
- 高トラフィック時: 変動大

**実装工数:**
- 学習コスト大（チーム全員初経験）
- 従来の開発パターンと異なる

## 決定理由

### モノリシックを選んだ主な理由

#### 1. チームサイズと経験
- 3名の小規模チーム
- マイクロサービス経験なし
- モノリシックアーキテクチャなら全員が経験あり
- すぐに開発開始可能

#### 2. 開発速度
MVP開発3ヶ月という制約:
- モノリシック: 実装に集中可能
- マイクロサービス: アーキテクチャ構築に4-6週間必要
- サーバーレス: 学習コストが大きい

#### 3. シンプルさ
- デバッグが容易（単一プロセス）
- ログ管理がシンプル
- トランザクション管理が容易（単一DB）
- デプロイが単純（単一アプリケーション）

#### 4. コスト
- 月$110程度（予算$500に対して余裕）
- マイクロサービスの半分以下

#### 5. 十分なスケーラビリティ
初年度想定（10,000ユーザー）には十分:
- 垂直スケーリング（EC2インスタンスサイズアップ）
- 水平スケーリング（インスタンス追加）
- キャッシュ追加（Redis）
- CDN活用

参考: Instagram は初期、モノリシックアーキテクチャで数百万ユーザーに対応

#### 6. 将来の選択肢を残す
モジュラーモノリスとして設計:
- 機能ごとにモジュール分離
- 明確なインターフェース
- 将来的なマイクロサービス化が容易

### マイクロサービスを選ばなかった理由
- **開発速度**: MVP開発期間に間に合わない
- **チーム経験**: 誰もマイクロサービス経験がない
- **複雑さ**: 小規模チームには過剰
- **コスト**: 予算の半分以上を消費
- **必要性**: 現時点で必要なスケールではない

### サーバーレスを選ばなかった理由
- **学習コスト**: チーム全員が初経験
- **制約**: コールドスタート、実行時間制限
- **デバッグ**: 従来の開発フローと大きく異なる
- **実績**: チーム内に成功事例なし

## 影響

### ポジティブな影響

#### 開発速度
- すぐに実装開始可能
- デバッグが容易
- 機能追加が迅速
- MVP を期間内にリリース可能

#### チーム生産性
- 全員が貢献可能（専門的な知識不要）
- オーバーヘッドが少ない
- フォーカスできる（アーキテクチャではなく機能に）

#### 運用
- シンプルな監視
- 単一のログストリーム
- デプロイが容易

#### コスト
- 月$110程度（予算の22%）
- スケールアップの余地が大きい

### ネガティブな影響（トレードオフ）

#### スケーラビリティの制約
- 垂直スケーリングに限界あり（1台のサーバー能力）
- 機能ごとの独立スケーリング不可
- ただし、キャッシュやCDNで緩和可能

#### デプロイ
- 全体をデプロイ（部分デプロイ不可）
- ダウンタイム発生の可能性
- ただし、Blue-Greenデプロイで緩和可能

#### 将来的な技術的負債
- モノリスが肥大化する可能性
- ただし、モジュラー設計で緩和

## 移行戦略（将来のマイクロサービス化）

マイクロサービス化が必要になった場合の戦略:

### トリガー
以下の場合、マイクロサービス化を検討:
1. ユーザー数が100,000人を超える
2. チームサイズが10人を超える
3. 特定機能のスケーリング要件が大きく異なる

### 段階的な移行
```
フェーズ1: モジュラーモノリス（現在）
- 明確なモジュール境界
- API化（内部API）

フェーズ2: 最初のサービス分離
- 最もスケーラビリティが必要な機能を分離
  （例: 決済サービス、検索サービス）

フェーズ3: 段階的な分離
- 1つずつサービスを分離
- リスク最小化

フェーズ4: 完全なマイクロサービス
```

### モジュラーモノリスの原則
将来の分離を容易にするため:
- モジュール間は明確なインターフェースで通信
- 直接的なDB共有を避ける（Repository層を経由）
- モジュール間の依存は一方向のみ

## 実装結果（2025-09-20追記）

### パフォーマンス
- APIレスポンスタイム: 平均200ms（95パーセンタイル: 500ms）
- 同時接続: 100ユーザーで問題なし
- データベースクエリ: 平均10ms

### 開発速度
- MVP: 予定通り3ヶ月でリリース
- 機能追加速度: 平均1機能/週

### 運用
- デプロイ頻度: 週2回
- ダウンタイム: Blue-Greenデプロイで0
- 障害: 1件（データベース接続エラー、5分で復旧）

### コスト
- 実際のコスト: 月$115（想定$110とほぼ同じ）

### チームの満足度
- 開発体験: 良好（全員が貢献可能）
- デバッグの容易さ: 非常に良い
- ストレス: 低い（複雑性が少ない）

### 学んだこと
- モノリシックでも適切な設計で十分スケール
- モジュラー設計が将来の柔軟性を保証
- 小規模チームにはシンプルさが最も重要

## 将来の検討事項

### 見直しトリガー
以下の場合、アーキテクチャを再検討:

1. **ユーザー数**
   - 月間アクティブユーザー: 50,000人超
   - 同時接続: 1,000ユーザー超

2. **チーム規模**
   - 開発チーム: 10人以上
   - 複数チームに分割

3. **スケーリング要件の差異**
   - 特定機能のトラフィックが10倍以上
   - 例: 検索機能だけ負荷が高い

4. **技術的制約**
   - 単一サーバーでの処理限界
   - 垂直スケーリングのコスト増大

### 継続的な監視
- ユーザー数、トラフィック
- サーバーリソース使用率
- レスポンスタイム
- デプロイ頻度

## 参考資料
- Martin Fowler - Monolith First: https://martinfowler.com/bliki/MonolithFirst.html
- Sam Newman - Monolith to Microservices: https://samnewman.io/books/monolith-to-microservices/
- Amazon - モノリスからマイクロサービスへ: https://aws.amazon.com/microservices/
```

---

## 継続的な改善

設計判断の記録は、一度作成して終わりではありません。継続的に更新し、改善していくことが重要です。

### 記録の更新タイミング

**実装完了時:**
```markdown
## 実装結果（YYYY-MM-DD追記）

### 実測値
- [想定と実際の比較]

### 実装時の課題
- [遭遇した問題と解決策]

### 学んだこと
- [次回に活かせる知見]
```

**問題が発生した時:**
```markdown
## 障害記録（YYYY-MM-DD追記）

### 発生した問題
[何が起きたか]

### 原因
[判断のどの部分が問題だったか]

### 対応
[どう解決したか]

### 再発防止
[判断を変更するか、そのままでよいか]
```

**前提条件が変わった時:**
```markdown
## 前提条件の変化（YYYY-MM-DD追記）

### 変化した条件
- ユーザー数: 10,000 → 50,000
- チームサイズ: 3名 → 8名

### 影響評価
この判断は依然として有効か？

### 次のアクション
[判断を維持 / 見直しが必要]
```

### 定期的なレビュー

設計判断を定期的にレビューします。

**四半期レビューの例:**
```markdown
## 設計判断レビュー 2025-Q3

### レビュー日
2025-09-30

### レビュー対象
docs/decisions/ 配下のすべての判断

### レビュー結果

#### 001-database-selection.md
- ステータス: 有効
- 前提条件の変化: ユーザー数 5,000 → 12,000（2.4倍）
- 評価: 依然として適切。スケール可能。
- アクション: なし

#### 002-cache-strategy.md
- ステータス: 要見直し
- 前提条件の変化: キャッシュヒット率が想定80% → 実測95%
- 評価: 非常に効果的。他のAPIにも適用を検討すべき
- アクション: [#123] キャッシュ適用範囲の拡大検討

#### 005-architecture-monolith.md
- ステータス: 有効
- 前提条件の変化: ユーザー数増加、チーム拡大予定
- 評価: 現時点では適切だが、来年の見直しが必要
- アクション: Q4にマイクロサービス化の調査開始

### 全体的な傾向
- 多くの判断が適切に機能
- 想定以上の成長により、スケーリング戦略の再検討が必要
- 新技術（例: Rust）の検討も視野に

### 次回レビュー
2025-12-31
```

### チームでの振り返り

設計判断をチームで振り返ることで、組織の学習を促進します。

**月次の振り返り会:**
```markdown
## 設計判断振り返り会 2025-08

### 参加者
全エンジニア

### 今月の新しい判断
- 010-redis-cache.md

### 議論した内容

#### 良かった点
- 判断の記録があることで、新メンバーも背景を理解できた
- トレードオフが明確だった
- 実装後の結果も記録されていて参考になる

#### 改善点
- もう少し早く記録すべきだった（判断後1週間経過）
- 代替案の比較が浅い
- コスト試算に不確実性があった

#### 学んだこと
- キャッシュ設計は慎重に（後から変更困難）
- 実測が想定と異なることが多い
- 段階的な導入が有効

### アクションアイテム
- [ ] テンプレートに「不確実性」セクションを追加
- [ ] 判断後24時間以内に記録するルール化
```

### 記録の品質向上

**チェックリスト:**
```markdown
## 設計判断記録のセルフチェックリスト

記録を作成したら、以下を確認:

### 内容の完全性
- [ ] タイトルは明確か
- [ ] 判断日が記載されているか
- [ ] 状況・背景が詳しく説明されているか
- [ ] 前提条件が明記されているか
- [ ] 決定内容が具体的か
- [ ] 複数の選択肢を検討したか
- [ ] 各選択肢のメリット・デメリットを記載したか
- [ ] 決定理由が論理的か
- [ ] ポジティブ・ネガティブ両方の影響を記載したか
- [ ] 将来の見直しトリガーを明記したか

### 読みやすさ
- [ ] 構造が明確か（見出し、箇条書き）
- [ ] 専門用語は説明されているか
- [ ] 新メンバーでも理解できるか
- [ ] 簡潔か（冗長でないか）

### 実用性
- [ ] 将来の判断に役立つか
- [ ] 検索しやすいか（適切なキーワード）
- [ ] 関連ドキュメントへのリンクがあるか
- [ ] 参考資料が明記されているか

### 保守性
- [ ] 更新しやすい構造か
- [ ] ステータスが明確か
- [ ] 更新履歴を残せるか
```

**ピアレビュー:**
```markdown
# PR: 設計判断の記録 - Redisキャッシュ導入

## レビュー観点

### 内容
- 判断の背景は十分説明されているか
- 代替案の比較は適切か
- トレードオフは明確か

### 論理性
- 決定理由は納得できるか
- 矛盾はないか
- 根拠は明確か

### 実用性
- 将来の参考になるか
- 新メンバーが理解できるか

## レビューコメント

> ## 検討した選択肢

良い比較ですね。一点質問ですが、Memcachedの「メモリ効率が良い」
という点について、具体的にRedisと比べてどの程度の差がありますか？

→ 参考資料を追記しました。想定で約20-30%程度とのことです。

---

Approved!
```

---

## よくある落とし穴と対策

設計判断を記録する際に陥りがちな問題と、その対策を紹介します。

### 落とし穴1: 記録しない

**問題:**
- 忙しくて記録する時間がない
- 「覚えているから大丈夫」と思ってしまう
- 面倒に感じる

**影響:**
- 3ヶ月後には詳細を忘れる
- 同じ議論を繰り返す
- 新メンバーが背景を理解できない

**対策:**
```markdown
✅ 記録を習慣化する仕組み

1. **時間を確保する**
   - 技術選定会議の最後15分を記録時間に
   - または、会議後すぐに記録（当日中）

2. **テンプレートを活用**
   - 空欄を埋めるだけで完成
   - 考える時間を削減

3. **Pull Requestルール**
   - 大きな設計変更には必ず記録を含める
   - PRのチェックリストに追加

4. **小さく始める**
   - 最初は簡潔でOK
   - 後から詳細を追加

例:
## PR作成時のチェックリスト
- [ ] コード実装
- [ ] テスト
- [ ] 設計判断の記録（重要な変更の場合）
```

### 落とし穴2: 記録が長すぎて誰も読まない

**問題:**
- 詳細に書きすぎて10,000字を超える
- 誰も最後まで読まない
- 維持するのが大変

**影響:**
- 記録の意味がない
- 更新されなくなる

**対策:**
```markdown
✅ 適切な長さを保つ

1. **基本は1,000-2,000字程度**
   - 5分で読める長さ
   - 重要な判断でも3,000字まで

2. **構造化する**
   見出しで明確に区切り、必要な部分だけ読めるように

3. **詳細は別ドキュメントへ**
   # 決定内容
   Redisを使用したキャッシュレイヤーを導入

   詳細な実装方針: docs/cache-implementation.md
   パフォーマンステスト結果: docs/performance-test-results.md

4. **要約を最初に**
   ## TL;DR（要約）
   - 決定: Redisを採用
   - 理由: スケーラビリティとチームの経験
   - 影響: レスポンス80%改善、コスト月$50増

   詳細は以下...
```

### 落とし穴3: 事後的な正当化

**問題:**
- すでに決めた後で、その判断を正当化するために記録を書く
- デメリットやトレードオフを隠す
- 代替案を真剣に検討していない

**影響:**
- 記録の信頼性が失われる
- 将来の判断に役立たない
- チームの意思決定の質が低下

**対策:**
```markdown
✅ 誠実な記録

1. **デメリットも正直に書く**
   ❌ 悪い例:
   ## 決定理由
   Redisは完璧な選択だった。

   ✅ 良い例:
   ## 決定理由
   Redisを選んだが、以下のトレードオフがある:
   - コスト月$50増加
   - 運用複雑性の増加
   - ただし、パフォーマンス改善でカバー可能と判断

2. **検討した代替案を記録**
   実際に検討していない選択肢を無理に追加しない
   検討した案について、なぜ採用しなかったか正直に

3. **不確実性を明記**
   ## 不確実性
   - コスト試算は想定（実測ではない）
   - キャッシュヒット率80%は仮定
   - 実装後に検証が必要

4. **失敗も記録**
   ## ステータス
   廃止（2025-12-01）

   ## 廃止理由
   当初の判断は誤りだった。
   [詳細な理由...]
```

### 落とし穴4: 更新しない

**問題:**
- 一度記録したら更新しない
- 実装結果を追記しない
- 状況が変わっても記録が古いまま

**影響:**
- 記録が現実と乖離
- 信頼性の低下
- 新メンバーが混乱

**対策:**
```markdown
✅ 継続的な更新

1. **実装完了時に必ず更新**
   ## 実装結果（YYYY-MM-DD追記）
   - 想定と実際の比較
   - 学んだこと

2. **四半期ごとにレビュー**
   カレンダーに定期レビューを設定

3. **ステータスを明記**
   ## ステータス
   提案中 / 承認済み / 実装済み / 見直し中 / 廃止

4. **変更履歴を残す**
   ## 変更履歴
   - 2025-08-15: 初版作成
   - 2025-09-01: 実装結果追記
   - 2025-12-01: 適用範囲拡大

5. **Gitのコミット履歴を活用**
   git log でいつ何が変更されたか追跡可能
```

### 落とし穴5: テンプレートに縛られすぎる

**問題:**
- テンプレートの全項目を無理に埋めようとする
- 不要な情報まで記載
- 記録が形式的になる

**影響:**
- 記録が冗長
- 本質的な情報が埋もれる
- 記録することが目的化

**対策:**
```markdown
✅ 柔軟な記録

1. **必須項目のみ厳守**
   必須:
   - タイトル
   - 判断日
   - 状況（背景）
   - 決定内容
   - 決定理由

   任意:
   - 検討した選択肢（明白な場合は省略可）
   - 詳細なコスト試算
   - etc.

2. **判断の性質に応じて調整**
   小さな判断:
   - 簡潔に（500字程度）
   - 主要な理由のみ

   大きな判断:
   - 詳細に（2,000-3,000字）
   - 代替案の比較
   - 詳細なトレードオフ

3. **N/A（該当なし）を活用**
   ## 検討した選択肢
   N/A - 業界標準のベストプラクティスに従った
```

### 落とし穴6: 粒度が不適切

**問題:**
- 細かすぎる判断まで記録（変数名の命名など）
- 逆に、重要な判断を記録しない

**影響:**
- ノイズが多くなる
- 本当に重要な記録が埋もれる

**対策:**
```markdown
✅ 適切な粒度の判断基準

記録すべき判断:
- アーキテクチャに影響
- 後から変更が困難
- コストに影響（月$10以上）
- 複数の選択肢を検討した
- チーム全体に影響
- 2ヶ月後の自分が「なぜ?」と思いそうなもの

記録不要な判断:
- 明白な実装の詳細
- 簡単に変更可能なもの
- 個人の好みレベルのもの
- 公式ドキュメント通りの標準的な設定

判断に迷ったら:
「この判断の理由を新メンバーに説明する必要があるか?」
→ Yesなら記録
```

---

## チェックリスト

この章で学んだ内容を確認しましょう。

### 設計判断を記録する意義
- [ ] 記憶が薄れることを理解している
- [ ] チーム全体の知識共有の重要性を理解している
- [ ] 将来の変更への備えとなることを理解している
- [ ] コンテキストの保存の価値を理解している

### 記録すべき情報
- [ ] 基本情報（タイトル、日付、ステータス）を理解している
- [ ] Context（状況・背景）の重要性を理解している
- [ ] Decision（決定内容）を明確に記述できる
- [ ] Alternatives（代替案）を比較できる
- [ ] Rationale（理由）を論理的に説明できる
- [ ] Consequences（影響）を予測できる

### 記録のタイミング
- [ ] 判断を下した直後に記録する重要性を理解している
- [ ] 実装完了時に結果を追記することを理解している
- [ ] 定期的なレビューの必要性を理解している

### 実践的な記録方法
- [ ] Markdownファイルでの記録方法を理解している
- [ ] Gitでのバージョン管理の方法を理解している
- [ ] Pull Requestでのレビュー方法を理解している
- [ ] テンプレートを活用できる

### 継続的な改善
- [ ] 記録を更新するタイミングを理解している
- [ ] 定期的なレビューの方法を理解している
- [ ] チームでの振り返りの価値を理解している

### よくある落とし穴の回避
- [ ] 記録しないことの問題を理解している
- [ ] 適切な長さを保つことができる
- [ ] 誠実な記録の重要性を理解している
- [ ] 継続的に更新することを理解している
- [ ] 適切な粒度を判断できる

---

## 次のステップ

この章では、設計判断を記録する重要性と実践的な方法について学びました。次の第14章「ADR（Architecture Decision Records）」では、より構造化された形式での設計判断の記録方法を学びます。

ADRは、設計判断の記録を標準化し、一貫性を持たせるための軽量なフレームワークです。本章で学んだ原則を基に、ADRの具体的なテンプレートや管理方法、実践的な運用方法について詳しく解説します。

**関連する章:**
- 第1章「ドキュメント作成の原則」- ドキュメントの基本的な考え方
- 第12章「アーキテクチャ図の作成」- 設計を視覚化する方法
- 第14章「ADR（Architecture Decision Records）」- 構造化された記録方法
- 第17章「ドキュメント管理戦略」- 記録の配置と管理

**さらに学ぶために:**
- ADR GitHub: https://adr.github.io/
- Thoughtworks Technology Radar - ADR: https://www.thoughtworks.com/radar/techniques/lightweight-architecture-decision-records
- Michael Nygard - Documenting Architecture Decisions: https://cognitect.com/blog/2011/11/15/documenting-architecture-decisions
